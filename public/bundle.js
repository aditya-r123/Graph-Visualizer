/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles.css":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles.css ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `/* Reset and Base Styles */\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\n:root {\n    /* Dark Theme (Default) */\n    --primary-color: #6366f1;\n    --primary-dark: #4f46e5;\n    --secondary-color: #8b5cf6;\n    --accent-color: #06b6d4;\n    --success-color: #10b981;\n    --danger-color: #ef4444;\n    --warning-color: #f59e0b;\n    --info-color: #3b82f6;\n    \n    --bg-primary: #0f172a;\n    --bg-secondary: #1e293b;\n    --bg-tertiary: #334155;\n    --bg-card: rgba(30, 41, 59, 0.8);\n    \n    --text-primary: #f8fafc;\n    --text-secondary: #cbd5e1;\n    --text-muted: #64748b;\n    \n    --border-color: #475569;\n    --border-light: #64748b;\n    \n    --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);\n    --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);\n    --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);\n    --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1);\n    \n    --radius-sm: 0.375rem;\n    --radius-md: 0.5rem;\n    --radius-lg: 0.75rem;\n    --radius-xl: 1rem;\n    \n    --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n/* Light Theme */\n[data-theme=\"light\"] {\n    --primary-color: #6366f1;\n    --primary-dark: #4f46e5;\n    --secondary-color: #8b5cf6;\n    --accent-color: #06b6d4;\n    --success-color: #10b981;\n    --danger-color: #ef4444;\n    --warning-color: #f59e0b;\n    --info-color: #3b82f6;\n    \n    --bg-primary: #ffffff;\n    --bg-secondary: #f8fafc;\n    --bg-tertiary: #e2e8f0;\n    --bg-card: rgba(248, 250, 252, 0.9);\n    \n    --text-primary: #1e293b;\n    --text-secondary: #475569;\n    --text-muted: #64748b;\n    \n    --border-color: #cbd5e1;\n    --border-light: #e2e8f0;\n    \n    --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);\n    --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);\n    --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);\n    --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1);\n}\n\nbody {\n    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n    background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);\n    color: var(--text-primary);\n    min-height: 100vh;\n    overflow: hidden;\n    transition: var(--transition);\n}\n\n/* App Container */\n.app-container {\n    display: grid;\n    grid-template-columns: 320px 1fr;\n    grid-template-rows: 1fr auto;\n    height: 100vh;\n    gap: 0;\n}\n\n/* Sidebar */\n.sidebar {\n    background: var(--bg-card);\n    backdrop-filter: blur(20px);\n    border-right: 1px solid var(--border-color);\n    display: flex;\n    flex-direction: column;\n    overflow-y: auto;\n    scrollbar-width: thin;\n    scrollbar-color: var(--border-color) transparent;\n    transition: var(--transition);\n}\n\n.sidebar::-webkit-scrollbar {\n    width: 6px;\n}\n\n.sidebar::-webkit-scrollbar-track {\n    background: transparent;\n}\n\n.sidebar::-webkit-scrollbar-thumb {\n    background: var(--border-color);\n    border-radius: 3px;\n}\n\n.sidebar-header {\n    padding: 1.5rem;\n    border-bottom: 1px solid var(--border-color);\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n\n.logo {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n}\n\n.logo i {\n    font-size: 1.5rem;\n    color: var(--primary-color);\n}\n\n.logo h1 {\n    font-size: 1.25rem;\n    font-weight: 600;\n    color: var(--text-primary);\n}\n\n.theme-toggle {\n    background: var(--bg-tertiary);\n    border: 1px solid var(--border-color);\n    border-radius: var(--radius-md);\n    padding: 0.5rem;\n    color: var(--text-primary);\n    cursor: pointer;\n    transition: var(--transition);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 40px;\n    height: 40px;\n}\n\n.theme-toggle:hover {\n    background: var(--border-color);\n    transform: scale(1.05);\n}\n\n.theme-toggle i {\n    font-size: 1rem;\n}\n\n.sidebar-content {\n    flex: 1;\n    padding: 1.5rem;\n    display: flex;\n    flex-direction: column;\n    gap: 2rem;\n}\n\n.control-section {\n    background: var(--bg-secondary);\n    border-radius: var(--radius-lg);\n    padding: 1.25rem;\n    border: 1px solid var(--border-color);\n    transition: var(--transition);\n}\n\n.control-section h3 {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    font-size: 0.875rem;\n    font-weight: 600;\n    color: var(--text-secondary);\n    margin-bottom: 1rem;\n    text-transform: uppercase;\n    letter-spacing: 0.05em;\n}\n\n.control-section h3 i {\n    color: var(--primary-color);\n}\n\n.control-group {\n    margin-bottom: 1.25rem;\n}\n\n.control-group:last-child {\n    margin-bottom: 0;\n}\n\n.control-group label {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    font-size: 0.875rem;\n    font-weight: 500;\n    color: var(--text-primary);\n    margin-bottom: 0.5rem;\n}\n\n.control-group label i {\n    color: var(--accent-color);\n    width: 16px;\n}\n\n.control-group small {\n    font-size: 0.75rem;\n    color: var(--text-muted);\n    margin-top: 0.25rem;\n    display: block;\n}\n\n.slider-container {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n}\n\n.slider-container input[type=\"range\"] {\n    flex: 1;\n    height: 6px;\n    background: var(--bg-tertiary);\n    border-radius: 3px;\n    outline: none;\n    -webkit-appearance: none;\n}\n\n.slider-container input[type=\"range\"]::-webkit-slider-thumb {\n    -webkit-appearance: none;\n    width: 18px;\n    height: 18px;\n    background: var(--primary-color);\n    border-radius: 50%;\n    cursor: pointer;\n    transition: var(--transition);\n}\n\n.slider-container input[type=\"range\"]::-webkit-slider-thumb:hover {\n    background: var(--primary-dark);\n    transform: scale(1.1);\n}\n\n.slider-container span {\n    font-size: 0.875rem;\n    font-weight: 600;\n    color: var(--primary-color);\n    min-width: 2rem;\n    text-align: center;\n}\n\n.control-group input[type=\"number\"],\n.control-group input[type=\"text\"],\n.control-group select {\n    width: 100%;\n    padding: 0.75rem;\n    background: var(--bg-tertiary);\n    border: 1px solid var(--border-color);\n    border-radius: var(--radius-md);\n    color: var(--text-primary);\n    font-size: 0.875rem;\n    transition: var(--transition);\n}\n\n.control-group input[type=\"number\"]:focus,\n.control-group input[type=\"text\"]:focus,\n.control-group select:focus {\n    outline: none;\n    border-color: var(--primary-color);\n    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);\n}\n\n.control-group input[type=\"number\"]::placeholder,\n.control-group input[type=\"text\"]::placeholder {\n    color: var(--text-muted);\n}\n\n/* Color input styles */\n.control-group input[type=\"color\"] {\n    width: 100%;\n    height: 40px;\n    border: 1px solid var(--border-color);\n    border-radius: var(--radius-md);\n    background: var(--bg-secondary);\n    cursor: pointer;\n    transition: var(--transition);\n    padding: 0;\n    appearance: none;\n    -webkit-appearance: none;\n}\n\n.control-group input[type=\"color\"]:hover {\n    border-color: var(--primary-color);\n    transform: scale(1.02);\n}\n\n.control-group input[type=\"color\"]:focus {\n    outline: none;\n    border-color: var(--primary-color);\n    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);\n}\n\n/* Color input webkit styles */\n.control-group input[type=\"color\"]::-webkit-color-swatch-wrapper {\n    padding: 0;\n    border-radius: var(--radius-md);\n}\n\n.control-group input[type=\"color\"]::-webkit-color-swatch {\n    border: none;\n    border-radius: var(--radius-md);\n    box-shadow: var(--shadow-sm);\n}\n\n.edit-label-container {\n    display: flex;\n    gap: 0.5rem;\n    align-items: center;\n}\n\n.edit-label-container input {\n    flex: 1;\n}\n\n.edit-label-buttons {\n    display: flex;\n    gap: 0.25rem;\n}\n\n.btn-sm {\n    padding: 0.375rem 0.5rem;\n    font-size: 0.75rem;\n    min-width: auto;\n    width: 32px;\n    height: 32px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.btn-sm i {\n    font-size: 0.75rem;\n}\n\n/* Modal Styles */\n.modal-overlay {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.7);\n    backdrop-filter: blur(10px);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 1000;\n    animation: fadeIn 0.3s ease-out;\n}\n\n.modal-content {\n    background: var(--bg-card);\n    border: 1px solid var(--border-color);\n    border-radius: var(--radius-lg);\n    padding: 2rem;\n    max-width: 500px;\n    width: 90%;\n    max-height: 80vh;\n    overflow-y: auto;\n    box-shadow: var(--shadow-xl);\n    animation: slideIn 0.3s ease-out;\n}\n\n.modal-content h3 {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n    font-size: 1.25rem;\n    font-weight: 600;\n    color: var(--text-primary);\n    margin-bottom: 1rem;\n}\n\n.modal-content h3 i {\n    color: var(--primary-color);\n}\n\n.modal-content p {\n    color: var(--text-secondary);\n    margin-bottom: 1.5rem;\n    line-height: 1.6;\n}\n\n.modal-buttons {\n    display: flex;\n    gap: 0.75rem;\n    justify-content: flex-end;\n    margin-top: 1.5rem;\n}\n\n.load-options {\n    display: flex;\n    flex-direction: column;\n    gap: 1.5rem;\n}\n\n.load-section {\n    border: 1px solid var(--border-color);\n    border-radius: var(--radius-md);\n    padding: 1rem;\n}\n\n.load-section h4 {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    font-size: 0.875rem;\n    font-weight: 600;\n    color: var(--text-secondary);\n    margin-bottom: 0.75rem;\n    text-transform: uppercase;\n    letter-spacing: 0.05em;\n}\n\n.load-section h4 i {\n    color: var(--primary-color);\n}\n\n.load-graphs-list {\n    max-height: 200px;\n    overflow-y: auto;\n}\n\n.load-graph-item {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 0.75rem;\n    border: 1px solid var(--border-color);\n    border-radius: var(--radius-md);\n    margin-bottom: 0.5rem;\n    background: var(--bg-secondary);\n    transition: var(--transition);\n}\n\n.load-graph-item:hover {\n    background: var(--bg-tertiary);\n    border-color: var(--primary-color);\n}\n\n.load-graph-info {\n    flex: 1;\n}\n\n.load-graph-name {\n    font-weight: 600;\n    color: var(--text-primary);\n    margin-bottom: 0.25rem;\n}\n\n.load-graph-details {\n    font-size: 0.75rem;\n    color: var(--text-secondary);\n    margin-bottom: 0.25rem;\n}\n\n.load-graph-time {\n    font-size: 0.75rem;\n    color: var(--text-muted);\n}\n\n.load-graph-btn {\n    padding: 0.5rem 1rem;\n    font-size: 0.875rem;\n}\n\n.no-graphs {\n    text-align: center;\n    color: var(--text-muted);\n    font-style: italic;\n    padding: 1rem;\n}\n\n/* Buttons */\n.button-group {\n    display: flex;\n    flex-direction: column;\n    gap: 0.75rem;\n}\n\n.btn {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    gap: 0.5rem;\n    padding: 0.75rem 1rem;\n    border: none;\n    border-radius: var(--radius-md);\n    font-size: 0.875rem;\n    font-weight: 500;\n    cursor: pointer;\n    transition: var(--transition);\n    text-decoration: none;\n    position: relative;\n    overflow: hidden;\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    transform: none !important;\n}\n\n.btn::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: -100%;\n    width: 100%;\n    height: 100%;\n    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);\n    transition: left 0.5s;\n}\n\n.btn:hover:not(:disabled)::before {\n    left: 100%;\n}\n\n.btn-primary {\n    background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));\n    color: white;\n}\n\n.btn-primary:hover:not(:disabled) {\n    transform: translateY(-2px);\n    box-shadow: var(--shadow-lg);\n}\n\n.btn-primary.active {\n    background: linear-gradient(135deg, var(--success-color), #059669);\n    animation: pulse 2s infinite;\n}\n\n.btn-secondary {\n    background: var(--bg-tertiary);\n    color: var(--text-primary);\n    border: 1px solid var(--border-color);\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: var(--border-color);\n    transform: translateY(-1px);\n}\n\n.btn-success {\n    background: linear-gradient(135deg, var(--success-color), #059669);\n    color: white;\n}\n\n.btn-success:hover:not(:disabled) {\n    transform: translateY(-2px);\n    box-shadow: var(--shadow-lg);\n}\n\n.btn-danger {\n    background: linear-gradient(135deg, var(--danger-color), #dc2626);\n    color: white;\n}\n\n.btn-danger:hover:not(:disabled) {\n    transform: translateY(-2px);\n    box-shadow: var(--shadow-lg);\n}\n\n.btn-warning {\n    background: linear-gradient(135deg, var(--warning-color), #d97706);\n    color: white;\n}\n\n.btn-warning:hover:not(:disabled) {\n    transform: translateY(-2px);\n    box-shadow: var(--shadow-lg);\n}\n\n.btn-info {\n    background: linear-gradient(135deg, var(--info-color), #2563eb);\n    color: white;\n}\n\n.btn-info:hover:not(:disabled) {\n    transform: translateY(-2px);\n    box-shadow: var(--shadow-lg);\n}\n\n/* Saved Graphs */\n.saved-graphs {\n    margin-top: 1rem;\n    padding-top: 1rem;\n    border-top: 1px solid var(--border-color);\n}\n\n.saved-graphs h4 {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    font-size: 0.75rem;\n    font-weight: 600;\n    color: var(--text-secondary);\n    margin-bottom: 0.75rem;\n    text-transform: uppercase;\n    letter-spacing: 0.05em;\n}\n\n.saved-graphs h4 i {\n    color: var(--accent-color);\n}\n\n.saved-graphs-list {\n    max-height: 200px;\n    overflow-y: auto;\n    display: flex;\n    flex-direction: column;\n    gap: 0.5rem;\n}\n\n.saved-graph-item {\n    background: var(--bg-tertiary);\n    border: 1px solid var(--border-color);\n    border-radius: var(--radius-sm);\n    padding: 0.75rem;\n    cursor: pointer;\n    transition: var(--transition);\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n\n.saved-graph-item:hover {\n    background: var(--border-color);\n    transform: translateX(2px);\n}\n\n.saved-graph-info {\n    flex: 1;\n}\n\n.saved-graph-name {\n    font-size: 0.875rem;\n    font-weight: 500;\n    color: var(--text-primary);\n    margin-bottom: 0.25rem;\n}\n\n.saved-graph-details {\n    font-size: 0.75rem;\n    color: var(--text-muted);\n}\n\n.saved-graph-time {\n    font-size: 0.7rem;\n    color: var(--text-muted);\n    font-style: italic;\n    margin-top: 0.25rem;\n}\n\n.saved-graph-actions {\n    display: flex;\n    gap: 0.25rem;\n}\n\n.saved-graph-actions button {\n    background: none;\n    border: none;\n    color: var(--text-muted);\n    cursor: pointer;\n    padding: 0.25rem;\n    border-radius: var(--radius-sm);\n    transition: var(--transition);\n}\n\n.saved-graph-actions button:hover {\n    background: var(--border-color);\n    color: var(--text-primary);\n}\n\n.saved-graph-actions .edit-name-btn:hover {\n    color: var(--info-color);\n}\n\n.saved-graph-actions .delete-btn:hover {\n    color: var(--danger-color);\n}\n\n/* Statistics */\n.stats-grid {\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    gap: 1rem;\n    margin-bottom: 1rem;\n}\n\n.stat-item {\n    background: var(--bg-tertiary);\n    border-radius: var(--radius-md);\n    padding: 1rem;\n    text-align: center;\n    border: 1px solid var(--border-color);\n    transition: var(--transition);\n}\n\n.stat-item:hover {\n    transform: translateY(-2px);\n    box-shadow: var(--shadow-md);\n}\n\n.stat-value {\n    font-size: 1.5rem;\n    font-weight: 700;\n    color: var(--primary-color);\n    margin-bottom: 0.25rem;\n}\n\n.stat-label {\n    font-size: 0.75rem;\n    color: var(--text-muted);\n    text-transform: uppercase;\n    letter-spacing: 0.05em;\n}\n\n.distance-info,\n.path-info,\n.search-info {\n    background: var(--bg-tertiary);\n    border-radius: var(--radius-md);\n    padding: 0.75rem;\n    font-size: 0.875rem;\n    color: var(--text-secondary);\n    border-left: 3px solid var(--accent-color);\n    display: none;\n    margin-top: 0.75rem;\n}\n\n.distance-info.show,\n.path-info.show,\n.search-info.show {\n    display: block;\n    animation: slideIn 0.3s ease-out;\n}\n\n.path-info {\n    border-left-color: var(--warning-color);\n}\n\n.search-info {\n    border-left-color: var(--success-color);\n}\n\n@keyframes slideIn {\n    from {\n        opacity: 0;\n        transform: translateY(-10px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n/* Main Content */\n.main-content {\n    position: relative;\n    background: var(--bg-primary);\n    overflow: hidden;\n    transition: var(--transition);\n}\n\n.canvas-container {\n    position: relative;\n    width: 100%;\n    height: 100%;\n}\n\n#graphCanvas {\n    width: 100%;\n    height: 100%;\n    background: var(--bg-primary);\n    cursor: crosshair;\n    display: block;\n    transition: var(--transition);\n}\n\n/* Instructions Overlay */\n.instructions-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: rgba(15, 23, 42, 0.95);\n    backdrop-filter: blur(10px);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 1000;\n    animation: fadeIn 0.3s ease-out;\n}\n\n[data-theme=\"light\"] .instructions-overlay {\n    background: rgba(255, 255, 255, 0.95);\n}\n\n@keyframes fadeIn {\n    from {\n        opacity: 0;\n    }\n    to {\n        opacity: 1;\n    }\n}\n\n.instructions-content {\n    background: var(--bg-card);\n    border-radius: var(--radius-xl);\n    padding: 2rem;\n    max-width: 500px;\n    width: 90%;\n    border: 1px solid var(--border-color);\n    box-shadow: var(--shadow-xl);\n    transition: var(--transition);\n}\n\n.instructions-content h3 {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    font-size: 1.25rem;\n    font-weight: 600;\n    color: var(--text-primary);\n    margin-bottom: 1.5rem;\n    text-align: center;\n}\n\n.instructions-content h3 i {\n    color: var(--warning-color);\n}\n\n.instruction-grid {\n    display: grid;\n    gap: 1rem;\n    margin-bottom: 1.5rem;\n}\n\n.instruction-item {\n    display: flex;\n    align-items: center;\n    gap: 1rem;\n    padding: 1rem;\n    background: var(--bg-secondary);\n    border-radius: var(--radius-md);\n    border: 1px solid var(--border-color);\n    transition: var(--transition);\n}\n\n.instruction-item:hover {\n    transform: translateX(5px);\n    border-color: var(--primary-color);\n}\n\n.instruction-icon {\n    width: 40px;\n    height: 40px;\n    background: var(--primary-color);\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    color: white;\n    font-size: 1rem;\n    flex-shrink: 0;\n}\n\n.instruction-text {\n    font-size: 0.875rem;\n    color: var(--text-secondary);\n    line-height: 1.4;\n}\n\n.instruction-text strong {\n    color: var(--text-primary);\n}\n\n/* Status Bar */\n.status-bar {\n    grid-column: 1 / -1;\n    background: var(--bg-card);\n    border-top: 1px solid var(--border-color);\n    padding: 0.75rem 1.5rem;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    font-size: 0.875rem;\n    color: var(--text-secondary);\n    transition: var(--transition);\n}\n\n.status-item {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n.status-item i {\n    color: var(--accent-color);\n}\n\n/* Responsive Design */\n@media (max-width: 1024px) {\n    .app-container {\n        grid-template-columns: 280px 1fr;\n    }\n    \n    .sidebar-content {\n        padding: 1rem;\n    }\n}\n\n@media (max-width: 768px) {\n    .app-container {\n        grid-template-columns: 1fr;\n        grid-template-rows: auto 1fr auto;\n    }\n    \n    .sidebar {\n        order: 2;\n        border-right: none;\n        border-top: 1px solid var(--border-color);\n        max-height: 300px;\n    }\n    \n    .main-content {\n        order: 1;\n    }\n    \n    .status-bar {\n        order: 3;\n    }\n    \n    .stats-grid {\n        grid-template-columns: 1fr 1fr;\n    }\n}\n\n@media (max-width: 480px) {\n    .sidebar-content {\n        padding: 0.75rem;\n    }\n    \n    .control-section {\n        padding: 1rem;\n    }\n    \n    .instructions-content {\n        padding: 1.5rem;\n        margin: 1rem;\n    }\n    \n    .instruction-item {\n        flex-direction: column;\n        text-align: center;\n        gap: 0.75rem;\n    }\n}\n\n/* Canvas-specific styles for better interaction */\n#graphCanvas {\n    touch-action: none;\n}\n\n/* Selection states for vertices */\n.vertex-selected {\n    animation: pulse 2s infinite;\n}\n\n@keyframes pulse {\n    0%, 100% {\n        transform: scale(1);\n    }\n    50% {\n        transform: scale(1.05);\n    }\n}\n\n/* Hover effects for better UX */\n.control-group:hover {\n    transform: translateY(-1px);\n}\n\n.stat-item:hover .stat-value {\n    color: var(--accent-color);\n}\n\n/* Search animation states */\n.vertex-visited {\n    animation: visited 0.5s ease-out;\n}\n\n.vertex-path {\n    animation: path 0.5s ease-out;\n}\n\n@keyframes visited {\n    0% {\n        transform: scale(1);\n    }\n    50% {\n        transform: scale(1.2);\n    }\n    100% {\n        transform: scale(1);\n    }\n}\n\n@keyframes path {\n    0% {\n        transform: scale(1);\n    }\n    50% {\n        transform: scale(1.3);\n    }\n    100% {\n        transform: scale(1);\n    }\n} \n\n/* Edit Mode Styles */\n.edit-mode-info {\n    background: var(--bg-tertiary);\n    border-radius: var(--radius-md);\n    padding: 1rem;\n    margin-bottom: 1rem;\n    border-left: 3px solid var(--accent-color);\n}\n\n.edit-mode-info-text {\n    font-size: 0.875rem;\n    color: var(--text-secondary);\n}\n\n.edit-mode-item {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    margin-bottom: 0.5rem;\n}\n\n.edit-mode-item:last-child {\n    margin-bottom: 0;\n}\n\n.edit-mode-item i {\n    color: var(--accent-color);\n    width: 16px;\n    text-align: center;\n}\n\n.edit-mode-item strong {\n    color: var(--text-primary);\n    font-weight: 600;\n}\n\n#editControlsSection {\n    border: 2px solid var(--accent-color);\n    background: var(--bg-secondary);\n}\n\n#editControlsSection h3 {\n    color: var(--accent-color);\n}\n\n#vertexEditControls,\n#edgeEditControls {\n    margin-top: 1rem;\n    padding-top: 1rem;\n    border-top: 1px solid var(--border-color);\n}\n\n#vertexEditControls h4,\n#edgeEditControls h4 {\n    color: var(--text-primary);\n    font-size: 0.875rem;\n    font-weight: 600;\n    margin-bottom: 0.75rem;\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n/* Shake animation for edit mode */\n@keyframes shake {\n    0%, 100% { transform: translateX(0); }\n    25% { transform: translateX(-0.1px); }\n    75% { transform: translateX(0.1px); }\n}\n\n.edit-mode-shake {\n    animation: shake 0.1s infinite;\n} `, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://graph-creator/./src/styles.css?./node_modules/css-loader/dist/cjs.js\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("{\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://graph-creator/./node_modules/css-loader/dist/runtime/api.js?\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("{\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://graph-creator/./node_modules/css-loader/dist/runtime/noSourceMaps.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("{\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://graph-creator/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("{\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://graph-creator/./node_modules/style-loader/dist/runtime/insertBySelector.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("{\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://graph-creator/./node_modules/style-loader/dist/runtime/insertStyleElement.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://graph-creator/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("{\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://graph-creator/./node_modules/style-loader/dist/runtime/styleDomAPI.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("{\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://graph-creator/./node_modules/style-loader/dist/runtime/styleTagTransform.js?\n}");

/***/ }),

/***/ "./src/graphCreator.js":
/*!*****************************!*\
  !*** ./src/graphCreator.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GraphCreator: () => (/* binding */ GraphCreator)\n/* harmony export */ });\nclass GraphCreator {\n    constructor() {\n        this.canvas = document.getElementById('graphCanvas');\n        this.ctx = this.canvas.getContext('2d');\n        this.vertices = [];\n        this.edges = [];\n        this.nextVertexId = 1;\n        this.selectedVertices = [];\n        this.draggedVertex = null;\n        this.isDragging = false;\n        this.vertexSize = 25;\n        this.edgeType = 'straight';\n        this.edgeDirection = 'undirected'; // 'undirected', 'directed-forward', 'directed-backward'\n        this.defaultEdgeWeight = null;\n        this.isDistanceMode = false;\n        this.distanceModeVertices = [];\n        this.isSearching = false;\n        this.searchAnimation = null;\n        this.visitedVertices = new Set();\n        this.pathVertices = new Set();\n        this.currentTheme = 'dark';\n        this.savedGraphs = [];\n        this.autoSaveInterval = null;\n        this.editingVertex = null;\n        this.lastSavedState = null;\n        \n        // Edge dragging properties\n        this.draggedEdge = null;\n        this.isDraggingEdge = false;\n        this.edgeControlPointSize = 8;\n        \n        // Long-press and edit mode properties\n        this.longPressTimer = null;\n        this.longPressDuration = 2000; // 2 seconds\n        this.isLongPressing = false;\n        this.editModeElement = null; // Currently selected element for editing\n        this.editModeType = null; // 'vertex' or 'edge'\n        this.shakeAnimation = null;\n        this.shakeOffset = 0;\n        this.shakeDirection = 1;\n        \n        // Styling properties\n        this.vertexColor = '#1e293b';\n        this.vertexBorderColor = '#475569';\n        this.vertexFontSize = 14;\n        this.vertexFontFamily = 'Inter';\n        this.vertexFontColor = '#ffffff';\n        \n        this.edgeColor = '#6366f1';\n        this.edgeWidth = 3;\n        this.edgeFontSize = 14;\n        this.edgeFontFamily = 'Inter';\n        this.edgeFontColor = '#06b6d4';\n        \n        this.initializeCanvas();\n        this.initializeEventListeners();\n        this.loadSavedGraphs();\n        this.startAutoSave();\n        this.updateInfo();\n        this.updateStatus('Ready to create your graph!');\n        this.updateTime();\n        \n        // Update time every second\n        setInterval(() => this.updateTime(), 1000);\n    }\n    \n    initializeCanvas() {\n        // Set canvas size to match container\n        this.resizeCanvas();\n        \n        // Handle window resize\n        window.addEventListener('resize', () => {\n            this.resizeCanvas();\n            this.draw();\n        });\n        \n        // Update root node dropdown\n        this.updateRootDropdown();\n    }\n    \n    resizeCanvas() {\n        const container = this.canvas.parentElement;\n        this.canvas.width = container.clientWidth;\n        this.canvas.height = container.clientHeight;\n    }\n    \n    initializeEventListeners() {\n        // Canvas events\n        this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));\n        this.canvas.addEventListener('contextmenu', (e) => this.handleRightClick(e));\n        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));\n        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));\n        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));\n        \n        // Control events\n        document.getElementById('vertexSize').addEventListener('input', (e) => {\n            this.vertexSize = parseInt(e.target.value);\n            document.getElementById('vertexSizeValue').textContent = this.vertexSize;\n            this.draw();\n        });\n        \n        document.getElementById('edgeType').addEventListener('change', (e) => {\n            this.edgeType = e.target.value;\n            this.draw();\n        });\n        \n        document.getElementById('edgeDirection').addEventListener('change', (e) => {\n            this.edgeDirection = e.target.value;\n            this.draw();\n        });\n        \n        document.getElementById('calculateDistance').addEventListener('click', () => {\n            this.toggleDistanceMode();\n        });\n        \n        document.getElementById('clearGraph').addEventListener('click', () => {\n            this.clearGraph();\n        });\n        \n        document.getElementById('hideInstructions').addEventListener('click', () => {\n            this.hideInstructions();\n        });\n        \n        // Theme toggle\n        document.getElementById('themeToggle').addEventListener('click', () => {\n            this.toggleTheme();\n        });\n        \n        // Search controls\n        document.getElementById('runBFS').addEventListener('click', () => {\n            this.runBFS();\n        });\n        \n        document.getElementById('runDFS').addEventListener('click', () => {\n            this.runDFS();\n        });\n        \n        document.getElementById('stopSearch').addEventListener('click', () => {\n            this.stopSearch();\n        });\n        \n        // Save/Load controls\n        document.getElementById('saveGraph').addEventListener('click', () => {\n            this.saveGraph();\n        });\n        \n        document.getElementById('loadGraph').addEventListener('click', () => {\n            this.showLoadConfirmation();\n        });\n        \n        document.getElementById('takeScreenshot').addEventListener('click', () => {\n            this.takeScreenshot();\n        });\n        \n        // File input for loading\n        document.getElementById('loadFileInput').addEventListener('change', (e) => {\n            this.handleFileLoad(e);\n        });\n        \n        // Edit label controls\n        document.getElementById('saveLabelBtn').addEventListener('click', () => {\n            this.saveVertexLabel();\n        });\n        \n        document.getElementById('cancelLabelBtn').addEventListener('click', () => {\n            this.cancelVertexLabelEdit();\n        });\n        \n        // Enter key to save label, Escape to cancel\n        document.getElementById('editVertexLabel').addEventListener('keypress', (e) => {\n            if (e.key === 'Enter') {\n                this.saveVertexLabel();\n            }\n        });\n        \n        // Global escape key listener for canceling label edit\n        document.addEventListener('keydown', (e) => {\n            if (e.key === 'Escape' && this.editingVertex) {\n                this.cancelVertexLabelEdit();\n            } else if (e.key === 'Escape' && this.editModeElement) {\n                this.exitEditMode();\n            }\n        });\n        \n        // Edit mode controls\n        document.getElementById('exitEditMode').addEventListener('click', () => {\n            this.exitEditMode();\n        });\n        \n        document.getElementById('deleteSelectedElement').addEventListener('click', () => {\n            this.deleteSelectedElement();\n        });\n        \n        // Edit mode styling controls\n        document.getElementById('editVertexColor').addEventListener('change', (e) => {\n            if (this.editModeElement && this.editModeType === 'vertex') {\n                this.editModeElement.color = e.target.value;\n                this.draw();\n            }\n        });\n        \n        document.getElementById('editVertexBorderColor').addEventListener('change', (e) => {\n            if (this.editModeElement && this.editModeType === 'vertex') {\n                this.editModeElement.borderColor = e.target.value;\n                this.draw();\n            }\n        });\n        \n        document.getElementById('editVertexFontSize').addEventListener('input', (e) => {\n            if (this.editModeElement && this.editModeType === 'vertex') {\n                this.editModeElement.fontSize = parseInt(e.target.value);\n                document.getElementById('editVertexFontSizeValue').textContent = this.editModeElement.fontSize;\n                this.draw();\n            }\n        });\n        \n        document.getElementById('editVertexFontFamily').addEventListener('change', (e) => {\n            if (this.editModeElement && this.editModeType === 'vertex') {\n                this.editModeElement.fontFamily = e.target.value;\n                this.draw();\n            }\n        });\n        \n        document.getElementById('editVertexFontColor').addEventListener('change', (e) => {\n            if (this.editModeElement && this.editModeType === 'vertex') {\n                this.editModeElement.fontColor = e.target.value;\n                this.draw();\n            }\n        });\n        \n        document.getElementById('editEdgeColor').addEventListener('change', (e) => {\n            if (this.editModeElement && this.editModeType === 'edge') {\n                this.editModeElement.color = e.target.value;\n                this.draw();\n            }\n        });\n        \n        document.getElementById('editEdgeWidth').addEventListener('input', (e) => {\n            if (this.editModeElement && this.editModeType === 'edge') {\n                this.editModeElement.width = parseInt(e.target.value);\n                document.getElementById('editEdgeWidthValue').textContent = this.editModeElement.width;\n                this.draw();\n            }\n        });\n        \n        document.getElementById('editEdgeFontSize').addEventListener('input', (e) => {\n            if (this.editModeElement && this.editModeType === 'edge') {\n                this.editModeElement.fontSize = parseInt(e.target.value);\n                document.getElementById('editEdgeFontSizeValue').textContent = this.editModeElement.fontSize;\n                this.draw();\n            }\n        });\n        \n        document.getElementById('editEdgeFontFamily').addEventListener('change', (e) => {\n            if (this.editModeElement && this.editModeType === 'edge') {\n                this.editModeElement.fontFamily = e.target.value;\n                this.draw();\n            }\n        });\n        \n        document.getElementById('editEdgeFontColor').addEventListener('change', (e) => {\n            if (this.editModeElement && this.editModeType === 'edge') {\n                this.editModeElement.fontColor = e.target.value;\n                this.draw();\n            }\n        });\n        \n        // Original styling controls (for global styling)\n        document.getElementById('vertexColor').addEventListener('change', (e) => {\n            this.vertexColor = e.target.value;\n            this.draw();\n        });\n        \n        document.getElementById('vertexBorderColor').addEventListener('change', (e) => {\n            this.vertexBorderColor = e.target.value;\n            this.draw();\n        });\n        \n        document.getElementById('vertexFontSize').addEventListener('input', (e) => {\n            this.vertexFontSize = parseInt(e.target.value);\n            document.getElementById('vertexFontSizeValue').textContent = this.vertexFontSize;\n            this.draw();\n        });\n        \n        document.getElementById('vertexFontFamily').addEventListener('change', (e) => {\n            this.vertexFontFamily = e.target.value;\n            this.draw();\n        });\n        \n        document.getElementById('vertexFontColor').addEventListener('change', (e) => {\n            this.vertexFontColor = e.target.value;\n            this.draw();\n        });\n        \n        document.getElementById('edgeColor').addEventListener('change', (e) => {\n            this.edgeColor = e.target.value;\n            this.draw();\n        });\n        \n        document.getElementById('edgeWidth').addEventListener('input', (e) => {\n            this.edgeWidth = parseInt(e.target.value);\n            document.getElementById('edgeWidthValue').textContent = this.edgeWidth;\n            this.draw();\n        });\n        \n        document.getElementById('edgeFontSize').addEventListener('input', (e) => {\n            this.edgeFontSize = parseInt(e.target.value);\n            document.getElementById('edgeFontSizeValue').textContent = this.edgeFontSize;\n            this.draw();\n        });\n        \n        document.getElementById('edgeFontFamily').addEventListener('change', (e) => {\n            this.edgeFontFamily = e.target.value;\n            this.draw();\n        });\n        \n        document.getElementById('edgeFontColor').addEventListener('change', (e) => {\n            this.edgeFontColor = e.target.value;\n            this.draw();\n        });\n        \n        // Prevent default context menu\n        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());\n    }\n    \n    startAutoSave() {\n        // Auto-save every 30 seconds\n        this.autoSaveInterval = setInterval(() => {\n            if (this.vertices.length > 0) {\n                this.autoSave();\n            }\n        }, 30000);\n    }\n    \n    autoSave() {\n        // Only auto-save if there are unsaved changes\n        if (!this.hasUnsavedChanges()) {\n            return;\n        }\n        \n        const graphData = this.exportGraph();\n        const timestamp = new Date().toISOString();\n        \n        // Create a temporary auto-save entry (not added to saved graphs list)\n        const autoSaveData = {\n            name: `Graph ${new Date().toLocaleDateString()}`,\n            data: graphData,\n            timestamp: timestamp,\n            vertices: this.vertices.length,\n            edges: this.edges.length,\n            isAutoSave: true\n        };\n        \n        try {\n            localStorage.setItem('graph_autosave_current', JSON.stringify(autoSaveData));\n            this.updateStatus('Graph auto-saved');\n        } catch (error) {\n            console.error('Auto-save failed:', error);\n        }\n    }\n    \n    loadSavedGraphs() {\n        try {\n            const savedGraphsData = localStorage.getItem('savedGraphs');\n            if (savedGraphsData) {\n                const parsed = JSON.parse(savedGraphsData);\n                \n                // Handle migration from old format to new format\n                this.savedGraphs = parsed.map(graph => {\n                    if (graph.data) {\n                        // New format\n                        return graph;\n                    } else {\n                        // Old format - convert to new format\n                        return {\n                            name: graph.name || 'Unnamed Graph',\n                            data: graph,\n                            timestamp: graph.timestamp || new Date().toISOString(),\n                            vertices: graph.vertices || 0,\n                            edges: graph.edges || 0\n                        };\n                    }\n                });\n                \n                this.updateSavedGraphsList();\n            }\n        } catch (error) {\n            console.error('Failed to load saved graphs:', error);\n        }\n    }\n    \n    updateSavedGraphsList() {\n        const container = document.getElementById('savedGraphsList');\n        container.innerHTML = '';\n        \n        this.savedGraphs.slice(0, 5).forEach((savedGraph, index) => {\n            const item = document.createElement('div');\n            item.className = 'saved-graph-item';\n            item.innerHTML = `\n                <div class=\"saved-graph-info\">\n                    <div class=\"saved-graph-name\" data-index=\"${index}\">${savedGraph.name}</div>\n                    <div class=\"saved-graph-details\">${savedGraph.vertices} vertices, ${savedGraph.edges} edges</div>\n                    <div class=\"saved-graph-time\">Last edited: ${new Date(savedGraph.timestamp).toLocaleString()}</div>\n                </div>\n                <div class=\"saved-graph-actions\">\n                    <button class=\"edit-name-btn\" title=\"Edit graph name\">\n                        <i class=\"fas fa-edit\"></i>\n                    </button>\n                    <button class=\"load-btn\" title=\"Load graph\">\n                        <i class=\"fas fa-download\"></i>\n                    </button>\n                    <button class=\"delete-btn\" title=\"Delete saved graph\">\n                        <i class=\"fas fa-trash\"></i>\n                    </button>\n                </div>\n            `;\n            \n            // Add event listeners\n            const editNameBtn = item.querySelector('.edit-name-btn');\n            const loadBtn = item.querySelector('.load-btn');\n            const deleteBtn = item.querySelector('.delete-btn');\n            const nameElement = item.querySelector('.saved-graph-name');\n            \n            editNameBtn.addEventListener('click', (e) => {\n                e.stopPropagation();\n                this.editSavedGraphName(index, nameElement);\n            });\n            \n            loadBtn.addEventListener('click', (e) => {\n                e.stopPropagation();\n                this.loadSavedGraphWithConfirmation(savedGraph);\n            });\n            \n            deleteBtn.addEventListener('click', (e) => {\n                e.stopPropagation();\n                this.deleteSavedGraph(index);\n            });\n            \n            container.appendChild(item);\n        });\n    }\n    \n    saveGraph() {\n        if (this.vertices.length === 0) {\n            this.updateStatus('No graph to save');\n            return;\n        }\n        \n        const name = prompt('Enter a name for this graph:', `Graph ${new Date().toLocaleDateString()}`);\n        if (!name) return;\n        \n        const graphData = this.exportGraph();\n        const timestamp = new Date().toISOString();\n        \n        const savedGraph = {\n            name: name,\n            data: graphData,\n            timestamp: timestamp,\n            vertices: this.vertices.length,\n            edges: this.edges.length\n        };\n        \n        this.savedGraphs.unshift(savedGraph);\n        \n        // Keep only last 10 saved graphs\n        if (this.savedGraphs.length > 10) {\n            this.savedGraphs = this.savedGraphs.slice(0, 10);\n        }\n        \n        try {\n            localStorage.setItem('savedGraphs', JSON.stringify(this.savedGraphs));\n            this.updateSavedGraphsList();\n            this.lastSavedState = JSON.stringify({\n                vertices: this.vertices.map(v => ({ id: v.id, x: v.x, y: v.y, label: v.label })),\n                edges: this.edges.map(e => ({ from: e.from.id, to: e.to.id, weight: e.weight, type: e.type }))\n            });\n            this.updateStatus(`Graph \"${name}\" saved successfully!`);\n        } catch (error) {\n            console.error('Failed to save graph:', error);\n            this.updateStatus('Failed to save graph');\n        }\n    }\n    \n    loadSavedGraph(savedGraph) {\n        try {\n            this.importGraph(savedGraph.data);\n            this.updateStatus(`Loaded graph \"${savedGraph.name}\"`);\n        } catch (error) {\n            console.error('Failed to load graph:', error);\n            this.updateStatus('Failed to load graph');\n        }\n    }\n    \n    deleteSavedGraph(index) {\n        if (confirm('Are you sure you want to delete this saved graph?')) {\n            this.savedGraphs.splice(index, 1);\n            try {\n                localStorage.setItem('savedGraphs', JSON.stringify(this.savedGraphs));\n                this.updateSavedGraphsList();\n                this.updateStatus('Saved graph deleted');\n            } catch (error) {\n                console.error('Failed to delete saved graph:', error);\n            }\n        }\n    }\n    \n    editSavedGraphName(index, nameElement) {\n        const savedGraph = this.savedGraphs[index];\n        const newName = prompt('Enter new name for this graph:', savedGraph.name);\n        \n        if (newName && newName.trim() !== '' && newName.trim() !== savedGraph.name) {\n            savedGraph.name = newName.trim();\n            savedGraph.timestamp = new Date().toISOString();\n            \n            try {\n                localStorage.setItem('savedGraphs', JSON.stringify(this.savedGraphs));\n                this.updateSavedGraphsList();\n                this.updateStatus(`Graph renamed to \"${newName.trim()}\"`);\n            } catch (error) {\n                console.error('Failed to update saved graph:', error);\n                this.updateStatus('Failed to rename graph');\n            }\n        }\n    }\n    \n    loadSavedGraphWithConfirmation(savedGraph) {\n        // Always auto-save current graph if there are changes, then load the new graph\n        if (this.hasUnsavedChanges()) {\n            this.saveCurrentGraphAndLoadSpecific(savedGraph);\n        } else {\n            this.loadSavedGraph(savedGraph);\n        }\n    }\n    \n    saveCurrentGraphAndLoadSpecific(targetGraph) {\n        // First save the current graph\n        const graphData = this.exportGraph();\n        const timestamp = new Date().toISOString();\n        const name = `Graph ${new Date().toLocaleDateString()}`;\n        \n        const savedGraph = {\n            name: name,\n            data: graphData,\n            timestamp: timestamp,\n            vertices: this.vertices.length,\n            edges: this.edges.length\n        };\n        \n        // Add to saved graphs\n        this.savedGraphs.unshift(savedGraph);\n        if (this.savedGraphs.length > 10) {\n            this.savedGraphs = this.savedGraphs.slice(0, 10);\n        }\n        \n        // Save to localStorage\n        try {\n            localStorage.setItem('savedGraphs', JSON.stringify(this.savedGraphs));\n            this.updateSavedGraphsList();\n            this.updateStatus('Current graph saved before loading new graph');\n        } catch (error) {\n            console.error('Failed to save graph:', error);\n            this.updateStatus('Failed to save current graph');\n        }\n        \n        // Now load the target graph\n        this.loadSavedGraph(targetGraph);\n    }\n    \n    loadGraph() {\n        document.getElementById('loadFileInput').click();\n    }\n    \n    handleFileLoad(event) {\n        const file = event.target.files[0];\n        if (!file) return;\n        \n        const reader = new FileReader();\n        reader.onload = (e) => {\n            try {\n                const graphData = JSON.parse(e.target.result);\n                this.importGraph(graphData);\n                this.updateStatus(`Loaded graph from file: ${file.name}`);\n            } catch (error) {\n                console.error('Failed to parse graph file:', error);\n                this.updateStatus('Invalid graph file format');\n            }\n        };\n        reader.readAsText(file);\n        \n        // Reset file input\n        event.target.value = '';\n    }\n    \n    takeScreenshot() {\n        // Create a temporary canvas for the screenshot\n        const tempCanvas = document.createElement('canvas');\n        const tempCtx = tempCanvas.getContext('2d');\n        \n        // Set canvas size\n        tempCanvas.width = this.canvas.width;\n        tempCanvas.height = this.canvas.height;\n        \n        // Fill background\n        tempCtx.fillStyle = this.currentTheme === 'dark' ? '#0f172a' : '#ffffff';\n        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);\n        \n        // Draw the graph\n        this.drawOnCanvas(tempCtx, tempCanvas.width, tempCanvas.height);\n        \n        // Convert to blob and download\n        tempCanvas.toBlob((blob) => {\n            const url = URL.createObjectURL(blob);\n            const a = document.createElement('a');\n            a.href = url;\n            a.download = `graph-screenshot-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;\n            document.body.appendChild(a);\n            a.click();\n            document.body.removeChild(a);\n            URL.revokeObjectURL(url);\n            this.updateStatus('Screenshot saved!');\n        }, 'image/png');\n    }\n    \n    drawOnCanvas(ctx, width, height) {\n        // Clear canvas\n        ctx.clearRect(0, 0, width, height);\n        \n        // Draw edges\n        this.edges.forEach(edge => this.drawEdgeOnCanvas(ctx, edge));\n        \n        // Draw vertices\n        this.vertices.forEach(vertex => this.drawVertexOnCanvas(ctx, vertex));\n    }\n    \n    drawEdgeOnCanvas(ctx, edge) {\n        ctx.strokeStyle = '#6366f1';\n        ctx.lineWidth = 3;\n        ctx.lineCap = 'round';\n        ctx.beginPath();\n        \n        if (edge.type === 'curved') {\n            const midX = (edge.from.x + edge.to.x) / 2;\n            const midY = (edge.from.y + edge.to.y) / 2 - 40;\n            \n            ctx.moveTo(edge.from.x, edge.from.y);\n            ctx.quadraticCurveTo(midX, midY, edge.to.x, edge.to.y);\n        } else {\n            ctx.moveTo(edge.from.x, edge.from.y);\n            ctx.lineTo(edge.to.x, edge.to.y);\n        }\n        \n        ctx.stroke();\n        \n        if (edge.weight !== null && edge.weight !== '') {\n            const midX = (edge.from.x + edge.to.x) / 2;\n            const midY = (edge.from.y + edge.to.y) / 2;\n            \n            if (edge.type === 'curved') {\n                midY -= 20;\n            }\n            \n            ctx.fillStyle = this.currentTheme === 'dark' ? 'rgba(15, 23, 42, 0.9)' : 'rgba(255, 255, 255, 0.9)';\n            ctx.fillRect(midX - 20, midY - 12, 40, 24);\n            \n            ctx.fillStyle = '#06b6d4';\n            ctx.font = 'bold 14px Inter';\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            ctx.fillText(edge.weight.toString(), midX, midY);\n        }\n    }\n    \n    drawVertexOnCanvas(ctx, vertex) {\n        let fillColor = '#1e293b';\n        let borderColor = '#475569';\n        \n        if (this.pathVertices.has(vertex)) {\n            fillColor = '#10b981';\n            borderColor = '#059669';\n        } else if (this.visitedVertices.has(vertex)) {\n            fillColor = '#f59e0b';\n            borderColor = '#d97706';\n        } else if (this.selectedVertices.includes(vertex)) {\n            fillColor = '#6366f1';\n            borderColor = '#4f46e5';\n        } else if (this.distanceModeVertices.includes(vertex)) {\n            fillColor = '#f59e0b';\n            borderColor = '#d97706';\n        } else if (vertex === this.draggedVertex) {\n            fillColor = '#10b981';\n            borderColor = '#059669';\n        }\n        \n        if (this.currentTheme === 'light') {\n            if (fillColor === '#1e293b') {\n                fillColor = '#e2e8f0';\n                borderColor = '#cbd5e1';\n            }\n        }\n        \n        const gradient = ctx.createRadialGradient(\n            vertex.x - this.vertexSize * 0.3, \n            vertex.y - this.vertexSize * 0.3, \n            0,\n            vertex.x, \n            vertex.y, \n            this.vertexSize\n        );\n        gradient.addColorStop(0, fillColor);\n        gradient.addColorStop(1, this.adjustColor(fillColor, -20));\n        \n        ctx.fillStyle = gradient;\n        ctx.beginPath();\n        ctx.arc(vertex.x, vertex.y, this.vertexSize, 0, 2 * Math.PI);\n        ctx.fill();\n        \n        ctx.strokeStyle = borderColor;\n        ctx.lineWidth = 3;\n        ctx.stroke();\n        \n        ctx.fillStyle = this.currentTheme === 'dark' ? '#ffffff' : '#1e293b';\n        ctx.font = `bold ${Math.max(14, this.vertexSize / 2)}px Inter`;\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(vertex.label.toString(), vertex.x, vertex.y);\n    }\n    \n    exportGraph() {\n        return {\n            vertices: this.vertices.map(v => ({\n                id: v.id,\n                x: v.x,\n                y: v.y,\n                label: v.label,\n                color: v.color,\n                borderColor: v.borderColor,\n                fontSize: v.fontSize,\n                fontFamily: v.fontFamily,\n                fontColor: v.fontColor\n            })),\n            edges: this.edges.map(e => ({\n                from: e.from.id,\n                to: e.to.id,\n                weight: e.weight,\n                type: e.type,\n                direction: e.direction,\n                controlPoint: e.controlPoint,\n                color: e.color,\n                width: e.width,\n                fontSize: e.fontSize,\n                fontFamily: e.fontFamily,\n                fontColor: e.fontColor\n            })),\n            nextVertexId: this.nextVertexId,\n            vertexSize: this.vertexSize,\n            edgeType: this.edgeType,\n            edgeDirection: this.edgeDirection,\n            theme: this.currentTheme,\n            // Global styling properties\n            vertexColor: this.vertexColor,\n            vertexBorderColor: this.vertexBorderColor,\n            vertexFontSize: this.vertexFontSize,\n            vertexFontFamily: this.vertexFontFamily,\n            vertexFontColor: this.vertexFontColor,\n            edgeColor: this.edgeColor,\n            edgeWidth: this.edgeWidth,\n            edgeFontSize: this.edgeFontSize,\n            edgeFontFamily: this.edgeFontFamily,\n            edgeFontColor: this.edgeFontColor\n        };\n    }\n    \n    importGraph(graphData) {\n        // Clear current graph\n        this.vertices = [];\n        this.edges = [];\n        this.selectedVertices = [];\n        this.draggedVertex = null;\n        this.visitedVertices.clear();\n        this.pathVertices.clear();\n        this.editingVertex = null;\n        \n        // Import vertices\n        this.vertices = graphData.vertices.map(v => ({\n            id: v.id,\n            x: v.x,\n            y: v.y,\n            label: v.label,\n            color: v.color,\n            borderColor: v.borderColor,\n            fontSize: v.fontSize,\n            fontFamily: v.fontFamily,\n            fontColor: v.fontColor\n        }));\n        \n        // Import edges\n        this.edges = graphData.edges.map(e => {\n            const fromVertex = this.vertices.find(v => v.id === e.from);\n            const toVertex = this.vertices.find(v => v.id === e.to);\n            return {\n                from: fromVertex,\n                to: toVertex,\n                weight: e.weight,\n                type: e.type,\n                direction: e.direction || 'undirected',\n                controlPoint: e.controlPoint,\n                color: e.color,\n                width: e.width,\n                fontSize: e.fontSize,\n                fontFamily: e.fontFamily,\n                fontColor: e.fontColor\n            };\n        });\n        \n        // Import settings\n        this.nextVertexId = graphData.nextVertexId || this.vertices.length + 1;\n        this.vertexSize = graphData.vertexSize || 25;\n        this.edgeType = graphData.edgeType || 'straight';\n        this.edgeDirection = graphData.edgeDirection || 'undirected';\n        \n        // Import styling properties (with fallbacks)\n        this.vertexColor = graphData.vertexColor || '#1e293b';\n        this.vertexBorderColor = graphData.vertexBorderColor || '#475569';\n        this.vertexFontSize = graphData.vertexFontSize || 14;\n        this.vertexFontFamily = graphData.vertexFontFamily || 'Inter';\n        this.vertexFontColor = graphData.vertexFontColor || '#ffffff';\n        \n        this.edgeColor = graphData.edgeColor || '#6366f1';\n        this.edgeWidth = graphData.edgeWidth || 3;\n        this.edgeFontSize = graphData.edgeFontSize || 14;\n        this.edgeFontFamily = graphData.edgeFontFamily || 'Inter';\n        this.edgeFontColor = graphData.edgeFontColor || '#06b6d4';\n        \n        // Update UI\n        document.getElementById('vertexSize').value = this.vertexSize;\n        document.getElementById('vertexSizeValue').textContent = this.vertexSize;\n        document.getElementById('edgeType').value = this.edgeType;\n        document.getElementById('edgeDirection').value = this.edgeDirection;\n        \n        // Update styling UI\n        document.getElementById('vertexColor').value = this.vertexColor;\n        document.getElementById('vertexBorderColor').value = this.vertexBorderColor;\n        document.getElementById('vertexFontSize').value = this.vertexFontSize;\n        document.getElementById('vertexFontSizeValue').textContent = this.vertexFontSize;\n        document.getElementById('vertexFontFamily').value = this.vertexFontFamily;\n        document.getElementById('vertexFontColor').value = this.vertexFontColor;\n        \n        document.getElementById('edgeColor').value = this.edgeColor;\n        document.getElementById('edgeWidth').value = this.edgeWidth;\n        document.getElementById('edgeWidthValue').textContent = this.edgeWidth;\n        document.getElementById('edgeFontSize').value = this.edgeFontSize;\n        document.getElementById('edgeFontSizeValue').textContent = this.edgeFontSize;\n        document.getElementById('edgeFontFamily').value = this.edgeFontFamily;\n        document.getElementById('edgeFontColor').value = this.edgeFontColor;\n        \n        // Update theme if different\n        if (graphData.theme && graphData.theme !== this.currentTheme) {\n            this.currentTheme = graphData.theme;\n            document.documentElement.setAttribute('data-theme', this.currentTheme);\n            \n            const themeToggle = document.getElementById('themeToggle');\n            const icon = themeToggle.querySelector('i');\n            \n            if (this.currentTheme === 'light') {\n                icon.className = 'fas fa-sun';\n                themeToggle.title = 'Switch to dark mode';\n            } else {\n                icon.className = 'fas fa-moon';\n                themeToggle.title = 'Switch to light mode';\n            }\n        }\n        \n        // Hide edit label interface\n        document.getElementById('editLabelGroup').style.display = 'none';\n        \n        // Reset saved state since we're loading a new graph\n        this.lastSavedState = JSON.stringify({\n            vertices: this.vertices.map(v => ({ id: v.id, x: v.x, y: v.y, label: v.label })),\n            edges: this.edges.map(e => ({ from: e.from.id, to: e.to.id, weight: e.weight, type: e.type, direction: e.direction, controlPoint: e.controlPoint })),\n            vertexSize: this.vertexSize,\n            edgeType: this.edgeType,\n            edgeDirection: this.edgeDirection,\n            vertexColor: this.vertexColor,\n            vertexBorderColor: this.vertexBorderColor,\n            vertexFontSize: this.vertexFontSize,\n            vertexFontFamily: this.vertexFontFamily,\n            vertexFontColor: this.vertexFontColor,\n            edgeColor: this.edgeColor,\n            edgeWidth: this.edgeWidth,\n            edgeFontSize: this.edgeFontSize,\n            edgeFontFamily: this.edgeFontFamily,\n            edgeFontColor: this.edgeFontColor\n        });\n        \n        this.updateInfo();\n        this.draw();\n        \n        // Update root node dropdown\n        this.updateRootDropdown();\n    }\n    \n    toggleTheme() {\n        this.currentTheme = this.currentTheme === 'dark' ? 'light' : 'dark';\n        document.documentElement.setAttribute('data-theme', this.currentTheme);\n        \n        const themeToggle = document.getElementById('themeToggle');\n        const icon = themeToggle.querySelector('i');\n        \n        if (this.currentTheme === 'light') {\n            icon.className = 'fas fa-sun';\n            themeToggle.title = 'Switch to dark mode';\n        } else {\n            icon.className = 'fas fa-moon';\n            themeToggle.title = 'Switch to light mode';\n        }\n        \n        this.draw();\n        this.updateStatus(`Switched to ${this.currentTheme} mode`);\n    }\n    \n    getMousePos(e) {\n        const rect = this.canvas.getBoundingClientRect();\n        const scaleX = this.canvas.width / rect.width;\n        const scaleY = this.canvas.height / rect.height;\n        \n        return {\n            x: (e.clientX - rect.left) * scaleX,\n            y: (e.clientY - rect.top) * scaleY\n        };\n    }\n    \n    handleCanvasClick(e) {\n        const pos = this.getMousePos(e);\n        const clickedVertex = this.getVertexAt(pos.x, pos.y);\n        const clickedEdge = this.getEdgeAt(pos.x, pos.y);\n\n        // If clicking a curved edge control point, do nothing\n        if (clickedEdge && clickedEdge.type === 'curved' && clickedEdge.controlPoint) {\n            return;\n        }\n\n        // Only allow left-clicking a node to do something in distance mode or edit mode\n        if (clickedVertex) {\n            if (this.isDistanceMode) {\n                this.handleDistanceModeClick(clickedVertex);\n            } else if (this.editModeElement === clickedVertex && this.editModeType === 'vertex') {\n                // Already in edit mode for this vertex, do nothing (edit mode UI is in sidebar)\n            }\n            // Otherwise, do nothing\n            return;\n        }\n\n        // Otherwise, add a vertex\n        this.addVertex(pos.x, pos.y);\n    }\n    \n    handleRightClick(e) {\n        e.preventDefault();\n        const pos = this.getMousePos(e);\n        const clickedVertex = this.getVertexAt(pos.x, pos.y);\n        \n        if (clickedVertex) {\n            this.handleVertexRightClick(clickedVertex);\n        }\n    }\n    \n    handleVertexClick(vertex) {\n        // Only allow label/font/color editing in edit mode (handled in sidebar)\n        if (this.isDistanceMode) {\n            this.handleDistanceModeClick(vertex);\n        }\n        // Otherwise, do nothing\n    }\n    \n    handleVertexRightClick(vertex) {\n        if (this.isDistanceMode) {\n            this.handleDistanceModeClick(vertex);\n            return;\n        }\n        \n        // Add to selection for edge creation\n        if (!this.selectedVertices.includes(vertex)) {\n            this.selectedVertices.push(vertex);\n        }\n        \n        // Create edge if we have two vertices selected\n        if (this.selectedVertices.length === 2) {\n            const weight = document.getElementById('edgeWeight').value || this.defaultEdgeWeight;\n            this.addEdge(this.selectedVertices[0], this.selectedVertices[1], weight);\n            this.selectedVertices = [];\n            this.updateStatus('Edge created successfully!');\n        } else {\n            this.updateStatus(`Right-click another vertex to create an edge (${this.selectedVertices.length}/2)`);\n        }\n        \n        this.draw();\n    }\n    \n    handleDistanceModeClick(vertex) {\n        this.distanceModeVertices.push(vertex);\n        \n        if (this.distanceModeVertices.length === 2) {\n            const { distance, path } = this.calculateShortestPathDistance(this.distanceModeVertices[0], this.distanceModeVertices[1]);\n            this.showDistanceInfo(distance, path);\n            this.distanceModeVertices = [];\n            this.isDistanceMode = false;\n            this.updateStatus('Distance calculated!');\n        } else {\n            this.updateStatus('Click another vertex to calculate distance');\n        }\n        \n        this.draw();\n    }\n    \n    calculateShortestPathDistance(vertex1, vertex2) {\n        if (vertex1.id === vertex2.id) return { distance: 0, path: [vertex1] };\n        \n        const adjacencyList = this.getAdjacencyList();\n        const queue = [{ vertex: vertex1, distance: 0 }];\n        const visited = new Set();\n        const parent = {};\n        \n        visited.add(vertex1.id);\n        \n        while (queue.length > 0) {\n            const { vertex, distance } = queue.shift();\n            \n            if (vertex.id === vertex2.id) {\n                // Reconstruct path\n                const path = [];\n                let current = vertex;\n                while (current) {\n                    path.unshift(current);\n                    current = parent[current.id];\n                }\n                return { distance, path };\n            }\n            \n            const neighbors = adjacencyList[vertex.id] || [];\n            for (const neighbor of neighbors) {\n                if (!visited.has(neighbor.id)) {\n                    visited.add(neighbor.id);\n                    parent[neighbor.id] = vertex;\n                    queue.push({ vertex: neighbor, distance: distance + 1 });\n                }\n            }\n        }\n        \n        return { distance: -1, path: [] }; // No path found\n    }\n    \n    handleMouseDown(e) {\n        const pos = this.getMousePos(e);\n        const vertex = this.getVertexAt(pos.x, pos.y);\n        const edge = this.getEdgeAt(pos.x, pos.y);\n        \n        // Clear any existing long-press timer\n        if (this.longPressTimer) {\n            clearTimeout(this.longPressTimer);\n            this.longPressTimer = null;\n        }\n        \n        if (vertex) {\n            // Start long-press timer for vertex\n            this.longPressTimer = setTimeout(() => {\n                this.enterEditMode(vertex, 'vertex');\n            }, this.longPressDuration);\n            \n            this.draggedVertex = vertex;\n            this.isDragging = true;\n            this.dragStartX = pos.x;\n            this.dragStartY = pos.y;\n            this.canvas.style.cursor = 'grabbing';\n            this.updateStatus('Dragging vertex...');\n        } else if (edge && edge.type === 'curved' && edge.controlPoint) {\n            // Start long-press timer for edge\n            this.longPressTimer = setTimeout(() => {\n                this.enterEditMode(edge, 'edge');\n            }, this.longPressDuration);\n            \n            this.draggedEdge = edge;\n            this.isDraggingEdge = true;\n            this.canvas.style.cursor = 'grabbing';\n            this.updateStatus('Dragging edge curve...');\n        }\n    }\n    \n    handleMouseMove(e) {\n        if (this.isDragging && this.draggedVertex) {\n            const pos = this.getMousePos(e);\n            this.draggedVertex.x = pos.x;\n            this.draggedVertex.y = pos.y;\n            this.draw();\n        } else if (this.isDraggingEdge && this.draggedEdge) {\n            const pos = this.getMousePos(e);\n            this.draggedEdge.controlPoint.x = pos.x;\n            this.draggedEdge.controlPoint.y = pos.y;\n            this.draw();\n        } else {\n            const pos = this.getMousePos(e);\n            const vertex = this.getVertexAt(pos.x, pos.y);\n            const edge = this.getEdgeAt(pos.x, pos.y);\n            \n            if (vertex) {\n                this.canvas.style.cursor = 'grab';\n            } else if (edge && edge.type === 'curved' && edge.controlPoint) {\n                this.canvas.style.cursor = 'grab';\n            } else {\n                this.canvas.style.cursor = 'crosshair';\n            }\n        }\n    }\n    \n    handleMouseUp(e) {\n        // Clear long-press timer\n        if (this.longPressTimer) {\n            clearTimeout(this.longPressTimer);\n            this.longPressTimer = null;\n        }\n        \n        if (this.isDragging) {\n            const pos = this.getMousePos(e);\n            const dragDistance = Math.sqrt((pos.x - this.dragStartX) ** 2 + (pos.y - this.dragStartY) ** 2);\n            \n            this.isDragging = false;\n            this.draggedVertex = null;\n            this.canvas.style.cursor = 'crosshair';\n            \n            if (dragDistance >= 5) {\n                this.updateStatus('Vertex moved successfully!');\n            } else {\n                this.updateStatus('Vertex selected');\n            }\n        } else if (this.isDraggingEdge) {\n            this.isDraggingEdge = false;\n            this.draggedEdge = null;\n            this.canvas.style.cursor = 'crosshair';\n            this.updateStatus('Edge curve adjusted!');\n        }\n    }\n    \n    enterEditMode(element, type) {\n        // Exit any existing edit mode\n        this.exitEditMode();\n        \n        this.editModeElement = element;\n        this.editModeType = type;\n        this.isLongPressing = true;\n        \n        // Start shaking animation\n        this.startShakeAnimation();\n        \n        // Show edit controls in sidebar\n        this.showEditControls();\n        \n        this.updateStatus(`${type === 'vertex' ? 'Vertex' : 'Edge'} in edit mode - use sidebar to modify`);\n    }\n    \n    exitEditMode() {\n        if (this.editModeElement) {\n            // Stop shaking animation\n            this.stopShakeAnimation();\n            \n            // Hide edit controls\n            this.hideEditControls();\n            \n            this.editModeElement = null;\n            this.editModeType = null;\n            this.isLongPressing = false;\n            \n            this.updateStatus('Edit mode exited');\n        }\n    }\n    \n    startShakeAnimation() {\n        this.shakeOffset = 0;\n        this.shakeDirection = 1;\n        \n        const shake = () => {\n            if (this.editModeElement) {\n                this.shakeOffset += this.shakeDirection * 2;\n                if (Math.abs(this.shakeOffset) > 8) {\n                    this.shakeDirection *= -1;\n                }\n                this.draw();\n                this.shakeAnimation = requestAnimationFrame(shake);\n            }\n        };\n        \n        this.shakeAnimation = requestAnimationFrame(shake);\n    }\n    \n    stopShakeAnimation() {\n        if (this.shakeAnimation) {\n            cancelAnimationFrame(this.shakeAnimation);\n            this.shakeAnimation = null;\n        }\n        this.shakeOffset = 0;\n        this.draw();\n    }\n    \n    showEditControls() {\n        // Hide styling section\n        const stylingSection = document.getElementById('stylingSection');\n        if (stylingSection) {\n            stylingSection.style.display = 'none';\n        }\n        \n        // Show edit controls section\n        const editSection = document.getElementById('editControlsSection');\n        if (editSection) {\n            editSection.style.display = 'block';\n        }\n        \n        // Show basic controls (vertex size, edge type, etc.)\n        const basicControls = document.getElementById('basicControlsSection');\n        if (basicControls) {\n            basicControls.style.display = 'block';\n        }\n        \n        // Show tools section\n        const toolsSection = document.getElementById('toolsSection');\n        if (toolsSection) {\n            toolsSection.style.display = 'block';\n        }\n        \n        // Show info section\n        const infoSection = document.getElementById('infoSection');\n        if (infoSection) {\n            infoSection.style.display = 'block';\n        }\n        \n        // Show save/load section\n        const saveLoadSection = document.getElementById('saveLoadSection');\n        if (saveLoadSection) {\n            saveLoadSection.style.display = 'block';\n        }\n        \n        // Show search section\n        const searchSection = document.getElementById('searchSection');\n        if (searchSection) {\n            searchSection.style.display = 'block';\n        }\n        \n        // Populate edit mode info\n        const editModeInfo = document.getElementById('editModeInfo');\n        if (editModeInfo) {\n            if (this.editModeType === 'vertex') {\n                editModeInfo.innerHTML = `\n                    <div class=\"edit-mode-item\">\n                        <i class=\"fas fa-circle\"></i>\n                        <strong>Vertex:</strong> ${this.editModeElement.label}\n                    </div>\n                    <div class=\"edit-mode-item\">\n                        <i class=\"fas fa-map-marker-alt\"></i>\n                        <strong>Position:</strong> (${Math.round(this.editModeElement.x)}, ${Math.round(this.editModeElement.y)})\n                    </div>\n                `;\n                \n                // Show vertex edit controls\n                document.getElementById('vertexEditControls').style.display = 'block';\n                document.getElementById('edgeEditControls').style.display = 'none';\n                \n                // Populate current values\n                document.getElementById('editVertexColor').value = this.editModeElement.color || this.vertexColor;\n                document.getElementById('editVertexBorderColor').value = this.editModeElement.borderColor || this.vertexBorderColor;\n                document.getElementById('editVertexFontSize').value = this.editModeElement.fontSize || this.vertexFontSize;\n                document.getElementById('editVertexFontSizeValue').textContent = this.editModeElement.fontSize || this.vertexFontSize;\n                document.getElementById('editVertexFontFamily').value = this.editModeElement.fontFamily || this.vertexFontFamily;\n                document.getElementById('editVertexFontColor').value = this.editModeElement.fontColor || this.vertexFontColor;\n                \n            } else if (this.editModeType === 'edge') {\n                editModeInfo.innerHTML = `\n                    <div class=\"edit-mode-item\">\n                        <i class=\"fas fa-minus\"></i>\n                        <strong>Edge:</strong> ${this.editModeElement.from.label}  ${this.editModeElement.to.label}\n                    </div>\n                    <div class=\"edit-mode-item\">\n                        <i class=\"fas fa-weight-hanging\"></i>\n                        <strong>Weight:</strong> ${this.editModeElement.weight || 'None'}\n                    </div>\n                `;\n                \n                // Show edge edit controls\n                document.getElementById('edgeEditControls').style.display = 'block';\n                document.getElementById('vertexEditControls').style.display = 'none';\n                \n                // Populate current values\n                document.getElementById('editEdgeColor').value = this.editModeElement.color || this.edgeColor;\n                document.getElementById('editEdgeWidth').value = this.editModeElement.width || this.edgeWidth;\n                document.getElementById('editEdgeWidthValue').textContent = this.editModeElement.width || this.edgeWidth;\n                document.getElementById('editEdgeFontSize').value = this.editModeElement.fontSize || this.edgeFontSize;\n                document.getElementById('editEdgeFontSizeValue').textContent = this.editModeElement.fontSize || this.edgeFontSize;\n                document.getElementById('editEdgeFontFamily').value = this.editModeElement.fontFamily || this.edgeFontFamily;\n                document.getElementById('editEdgeFontColor').value = this.editModeElement.fontColor || this.edgeFontColor;\n            }\n        }\n    }\n    \n    hideEditControls() {\n        // Hide the edit controls section\n        const editSection = document.getElementById('editControlsSection');\n        if (editSection) {\n            editSection.style.display = 'none';\n        }\n        // Show all other control sections except edit controls\n        document.querySelectorAll('.control-section').forEach(section => {\n            if (section.id !== 'editControlsSection') {\n                section.style.display = 'block';\n            }\n        });\n    }\n    \n    deleteSelectedElement() {\n        if (!this.editModeElement || !this.editModeType) return;\n        \n        if (this.editModeType === 'vertex') {\n            // Remove all edges connected to this vertex\n            this.edges = this.edges.filter(edge => \n                edge.from.id !== this.editModeElement.id && edge.to.id !== this.editModeElement.id\n            );\n            \n            // Remove the vertex\n            this.vertices = this.vertices.filter(v => v.id !== this.editModeElement.id);\n            \n            this.updateStatus(`Vertex \"${this.editModeElement.label}\" deleted`);\n        } else if (this.editModeType === 'edge') {\n            // Remove the edge\n            this.edges = this.edges.filter(edge => edge !== this.editModeElement);\n            \n            this.updateStatus('Edge deleted');\n        }\n        \n        this.exitEditMode();\n        this.updateInfo();\n        this.draw();\n        this.updateRootDropdown();\n    }\n    \n    getVertexAt(x, y) {\n        return this.vertices.find(vertex => {\n            const distance = Math.sqrt((vertex.x - x) ** 2 + (vertex.y - y) ** 2);\n            return distance <= this.vertexSize;\n        });\n    }\n    \n    getEdgeAt(x, y) {\n        return this.edges.find(edge => {\n            if (edge.type === 'curved' && edge.controlPoint) {\n                const distance = Math.sqrt((edge.controlPoint.x - x) ** 2 + (edge.controlPoint.y - y) ** 2);\n                return distance <= this.edgeControlPointSize;\n            }\n            return false;\n        });\n    }\n    \n    addVertex(x, y) {\n        const customLabel = document.getElementById('vertexLabel').value.trim();\n        let label = customLabel;\n        \n        if (!label) {\n            // Auto-generate label - find the next available numeric label\n            label = this.findNextAvailableLabel();\n        } else {\n            // Check if custom label already exists\n            const existingVertex = this.vertices.find(v => v.label === label);\n            if (existingVertex) {\n                this.updateStatus(`Label \"${label}\" already exists! Each vertex must have a unique label.`);\n                return;\n            }\n        }\n        \n        const vertex = {\n            id: this.nextVertexId++,\n            x: x,\n            y: y,\n            label: label\n        };\n        \n        this.vertices.push(vertex);\n        this.updateInfo();\n        this.draw();\n        this.updateStatus(`Vertex \"${label}\" added!`);\n        \n        // Clear custom label input\n        document.getElementById('vertexLabel').value = '';\n        this.updateRootDropdown();\n    }\n    \n    findNextAvailableLabel() {\n        // Get all existing labels\n        const existingLabels = this.vertices.map(v => v.label);\n        \n        // Try to find the first available numeric label starting from 1\n        let nextLabel = 1;\n        while (existingLabels.includes(nextLabel.toString())) {\n            nextLabel++;\n        }\n        \n        return nextLabel.toString();\n    }\n    \n    addEdge(vertex1, vertex2, weight = null) {\n        // Check if edge already exists\n        const existingEdge = this.edges.find(edge => \n            (edge.from === vertex1 && edge.to === vertex2) ||\n            (edge.from === vertex2 && edge.to === vertex1)\n        );\n        \n        if (!existingEdge) {\n            const edge = {\n                from: vertex1,\n                to: vertex2,\n                weight: weight,\n                type: this.edgeType,\n                direction: this.edgeDirection\n            };\n            // Remove control point for curved edges (always use fixed curve)\n            // No edge.controlPoint\n            this.edges.push(edge);\n        }\n        this.draw();\n    }\n    \n    getAdjacencyList() {\n        const adjacencyList = {};\n        \n        this.vertices.forEach(vertex => {\n            adjacencyList[vertex.id] = [];\n        });\n        \n        this.edges.forEach(edge => {\n            adjacencyList[edge.from.id].push(edge.to);\n            adjacencyList[edge.to.id].push(edge.from);\n        });\n        \n        return adjacencyList;\n    }\n    \n    findVertexByLabel(label) {\n        return this.vertices.find(vertex => vertex.label === label);\n    }\n    \n    findMostUpwardVertex() {\n        if (this.vertices.length === 0) return null;\n        return this.vertices.reduce((mostUpward, vertex) => {\n            return vertex.y < mostUpward.y ? vertex : mostUpward;\n        });\n    }\n    \n    async runBFS() {\n        const targetLabel = document.getElementById('searchTarget').value.trim();\n        const rootLabel = document.getElementById('searchRoot').value;\n        if (!targetLabel) {\n            this.updateStatus('Please enter a target vertex label');\n            return;\n        }\n        const targetVertex = this.findVertexByLabel(targetLabel);\n        if (!targetVertex) {\n            this.updateStatus(`Vertex \"${targetLabel}\" not found`);\n            return;\n        }\n        if (this.vertices.length === 0) {\n            this.updateStatus('No vertices to search');\n            return;\n        }\n        let startVertex;\n        if (rootLabel) {\n            startVertex = this.findVertexByLabel(rootLabel);\n            if (!startVertex) {\n                this.updateStatus(`Root vertex \"${rootLabel}\" not found`);\n                return;\n            }\n        } else {\n            startVertex = this.findMostUpwardVertex();\n        }\n        // Check if root node is connected to at least one other node\n        const adjacencyList = this.getAdjacencyList();\n        if (!adjacencyList[startVertex.id] || adjacencyList[startVertex.id].length === 0) {\n            this.updateStatus('Root node must be connected to at least one other node');\n            return;\n        }\n        this.startSearch();\n        await this.animateBFS(targetVertex, startVertex);\n    }\n    \n    async runDFS() {\n        const targetLabel = document.getElementById('searchTarget').value.trim();\n        const rootLabel = document.getElementById('searchRoot').value;\n        if (!targetLabel) {\n            this.updateStatus('Please enter a target vertex label');\n            return;\n        }\n        const targetVertex = this.findVertexByLabel(targetLabel);\n        if (!targetVertex) {\n            this.updateStatus(`Vertex \"${targetLabel}\" not found`);\n            return;\n        }\n        if (this.vertices.length === 0) {\n            this.updateStatus('No vertices to search');\n            return;\n        }\n        let startVertex;\n        if (rootLabel) {\n            startVertex = this.findVertexByLabel(rootLabel);\n            if (!startVertex) {\n                this.updateStatus(`Root vertex \"${rootLabel}\" not found`);\n                return;\n            }\n        } else {\n            startVertex = this.findMostUpwardVertex();\n        }\n        // Check if root node is connected to at least one other node\n        const adjacencyList = this.getAdjacencyList();\n        if (!adjacencyList[startVertex.id] || adjacencyList[startVertex.id].length === 0) {\n            this.updateStatus('Root node must be connected to at least one other node');\n            return;\n        }\n        this.startSearch();\n        await this.animateDFS(targetVertex, startVertex);\n    }\n    \n    startSearch() {\n        this.isSearching = true;\n        this.visitedVertices.clear();\n        this.pathVertices.clear();\n        \n        document.getElementById('runBFS').disabled = true;\n        document.getElementById('runDFS').disabled = true;\n        document.getElementById('stopSearch').disabled = false;\n        \n        this.updateStatus('Searching...');\n    }\n    \n    stopSearch() {\n        this.isSearching = false;\n        this.visitedVertices.clear();\n        this.pathVertices.clear();\n        \n        document.getElementById('runBFS').disabled = false;\n        document.getElementById('runDFS').disabled = false;\n        document.getElementById('stopSearch').disabled = true;\n        \n        this.draw();\n        this.updateStatus('Search stopped');\n    }\n    \n    async animateBFS(targetVertex, startVertex) {\n        const adjacencyList = this.getAdjacencyList();\n        const queue = [startVertex]; // Start from the specified starting vertex\n        const visited = new Set();\n        const parent = {};\n        \n        visited.add(startVertex.id);\n        \n        while (queue.length > 0 && this.isSearching) {\n            const current = queue.shift();\n            \n            // Mark as visited\n            this.visitedVertices.add(current);\n            this.draw();\n            await this.sleep(500);\n            \n            if (current.id === targetVertex.id) {\n                // Found target, reconstruct path\n                this.reconstructPath(parent, targetVertex);\n                this.showSearchResult(true, 'BFS');\n                return;\n            }\n            \n            // Add neighbors to queue\n            const neighbors = adjacencyList[current.id] || [];\n            for (const neighbor of neighbors) {\n                if (!visited.has(neighbor.id)) {\n                    visited.add(neighbor.id);\n                    parent[neighbor.id] = current;\n                    queue.push(neighbor);\n                }\n            }\n        }\n        \n        if (this.isSearching) {\n            this.showSearchResult(false, 'BFS');\n        }\n    }\n    \n    async animateDFS(targetVertex, startVertex) {\n        const adjacencyList = this.getAdjacencyList();\n        const visited = new Set();\n        const parent = {};\n        \n        const dfs = async (current) => {\n            if (!this.isSearching) return false;\n            \n            visited.add(current.id);\n            this.visitedVertices.add(current);\n            this.draw();\n            await this.sleep(500);\n            \n            if (current.id === targetVertex.id) {\n                this.reconstructPath(parent, targetVertex);\n                this.showSearchResult(true, 'DFS');\n                return true;\n            }\n            \n            const neighbors = adjacencyList[current.id] || [];\n            for (const neighbor of neighbors) {\n                if (!visited.has(neighbor.id)) {\n                    parent[neighbor.id] = current;\n                    const found = await dfs(neighbor);\n                    if (found) return true;\n                }\n            }\n            \n            return false;\n        };\n        \n        const found = await dfs(startVertex);\n        if (!found && this.isSearching) {\n            this.showSearchResult(false, 'DFS');\n        }\n    }\n    \n    reconstructPath(parent, targetVertex) {\n        const path = [];\n        let current = targetVertex;\n        \n        while (current) {\n            path.unshift(current);\n            current = parent[current.id];\n        }\n        \n        this.pathVertices = new Set(path);\n        this.draw();\n    }\n    \n    showSearchResult(found, algorithm) {\n        this.isSearching = false;\n        \n        document.getElementById('runBFS').disabled = false;\n        document.getElementById('runDFS').disabled = false;\n        document.getElementById('stopSearch').disabled = true;\n        \n        const searchInfo = document.getElementById('searchInfo');\n        if (found) {\n            searchInfo.textContent = `${algorithm} found target! Path length: ${this.pathVertices.size}`;\n            this.updateStatus(`${algorithm} found target vertex!`);\n        } else {\n            searchInfo.textContent = `${algorithm} did not find target vertex`;\n            this.updateStatus(`${algorithm} completed - target not found`);\n        }\n        \n        searchInfo.classList.add('show');\n        \n        // Clear after 5 seconds\n        setTimeout(() => {\n            this.visitedVertices.clear();\n            this.pathVertices.clear();\n            searchInfo.classList.remove('show');\n            this.draw();\n        }, 5000);\n    }\n    \n    sleep(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n    \n    startVertexLabelEdit(vertex) {\n        this.editingVertex = vertex;\n        this.selectedVertices = [vertex]; // Select the vertex being edited\n        \n        // Show the edit interface\n        document.getElementById('editLabelGroup').style.display = 'block';\n        document.getElementById('editVertexLabel').value = vertex.label;\n        document.getElementById('editingVertexLabel').textContent = vertex.label;\n        \n        // Focus on the input\n        document.getElementById('editVertexLabel').focus();\n        document.getElementById('editVertexLabel').select();\n        \n        this.draw();\n        this.updateStatus(`Editing vertex \"${vertex.label}\" - Press Enter to save, Escape to cancel`);\n    }\n    \n    saveVertexLabel() {\n        if (!this.editingVertex) return;\n        \n        const newLabel = document.getElementById('editVertexLabel').value.trim();\n        if (!newLabel) {\n            this.updateStatus('Label cannot be empty!');\n            return;\n        }\n        \n        // Check if label already exists (except for the current vertex)\n        const existingVertex = this.vertices.find(v => v.label === newLabel && v.id !== this.editingVertex.id);\n        if (existingVertex) {\n            this.updateStatus(`Label \"${newLabel}\" already exists! Each vertex must have a unique label.`);\n            return;\n        }\n        \n        const oldLabel = this.editingVertex.label;\n        this.editingVertex.label = newLabel;\n        \n        // Hide the edit interface\n        this.cancelVertexLabelEdit();\n        \n        this.draw();\n        this.updateStatus(`Vertex label changed from \"${oldLabel}\" to \"${newLabel}\"`);\n        this.updateRootDropdown();\n    }\n    \n    cancelVertexLabelEdit() {\n        this.editingVertex = null;\n        this.selectedVertices = [];\n        \n        // Hide the edit interface\n        document.getElementById('editLabelGroup').style.display = 'none';\n        document.getElementById('editVertexLabel').value = '';\n        document.getElementById('editingVertexLabel').textContent = '';\n        \n        this.draw();\n        this.updateStatus('Label editing cancelled');\n    }\n    \n    hasUnsavedChanges() {\n        if (!this.lastSavedState) {\n            return this.vertices.length > 0 || this.edges.length > 0;\n        }\n        \n        const currentState = JSON.stringify({\n            vertices: this.vertices.map(v => ({ id: v.id, x: v.x, y: v.y, label: v.label })),\n            edges: this.edges.map(e => ({ from: e.from.id, to: e.to.id, weight: e.weight, type: e.type, direction: e.direction, controlPoint: e.controlPoint })),\n            vertexSize: this.vertexSize,\n            edgeType: this.edgeType,\n            edgeDirection: this.edgeDirection,\n            vertexColor: this.vertexColor,\n            vertexBorderColor: this.vertexBorderColor,\n            vertexFontSize: this.vertexFontSize,\n            vertexFontFamily: this.vertexFontFamily,\n            vertexFontColor: this.vertexFontColor,\n            edgeColor: this.edgeColor,\n            edgeWidth: this.edgeWidth,\n            edgeFontSize: this.edgeFontSize,\n            edgeFontFamily: this.edgeFontFamily,\n            edgeFontColor: this.edgeFontColor\n        });\n        \n        return currentState !== this.lastSavedState;\n    }\n    \n    showLoadConfirmation() {\n        if (!this.hasUnsavedChanges()) {\n            this.showLoadDialog();\n            return;\n        }\n        \n        const dialog = document.createElement('div');\n        dialog.className = 'modal-overlay';\n        dialog.innerHTML = `\n            <div class=\"modal-content\">\n                <h3><i class=\"fas fa-exclamation-triangle\"></i> Unsaved Changes</h3>\n                <p>You have unsaved changes in your current graph. What would you like to do?</p>\n                <div class=\"modal-buttons\">\n                    <button class=\"btn btn-success\" id=\"saveAndLoadBtn\">\n                        <i class=\"fas fa-save\"></i> Save & Load\n                    </button>\n                    <button class=\"btn btn-warning\" id=\"loadWithoutSaveBtn\">\n                        <i class=\"fas fa-folder-open\"></i> Load Without Saving\n                    </button>\n                    <button class=\"btn btn-secondary\" id=\"cancelLoadBtn\">\n                        <i class=\"fas fa-times\"></i> Cancel\n                    </button>\n                </div>\n            </div>\n        `;\n        \n        document.body.appendChild(dialog);\n        \n        // Add event listeners\n        document.getElementById('saveAndLoadBtn').addEventListener('click', () => {\n            this.saveCurrentGraphAndLoad();\n            document.body.removeChild(dialog);\n        });\n        \n        document.getElementById('loadWithoutSaveBtn').addEventListener('click', () => {\n            this.showLoadDialog();\n            document.body.removeChild(dialog);\n        });\n        \n        document.getElementById('cancelLoadBtn').addEventListener('click', () => {\n            document.body.removeChild(dialog);\n        });\n    }\n    \n    saveCurrentGraphAndLoad() {\n        // First save the current graph\n        const graphData = this.exportGraph();\n        const timestamp = new Date().toISOString();\n        const name = `Graph ${new Date().toLocaleDateString()}`;\n        \n        const savedGraph = {\n            name: name,\n            data: graphData,\n            timestamp: timestamp,\n            vertices: this.vertices.length,\n            edges: this.edges.length\n        };\n        \n        // Add to saved graphs\n        this.savedGraphs.unshift(savedGraph);\n        if (this.savedGraphs.length > 10) {\n            this.savedGraphs = this.savedGraphs.slice(0, 10);\n        }\n        \n        // Save to localStorage\n        try {\n            localStorage.setItem('savedGraphs', JSON.stringify(this.savedGraphs));\n            this.updateSavedGraphsList();\n            this.updateStatus('Current graph saved before loading new graph');\n        } catch (error) {\n            console.error('Failed to save graph:', error);\n            this.updateStatus('Failed to save current graph');\n        }\n        \n        // Now show load dialog\n        this.showLoadDialog();\n    }\n    \n    showLoadDialog() {\n        const dialog = document.createElement('div');\n        dialog.className = 'modal-overlay';\n        dialog.innerHTML = `\n            <div class=\"modal-content\">\n                <h3><i class=\"fas fa-folder-open\"></i> Load Graph</h3>\n                <div class=\"load-options\">\n                    <div class=\"load-section\">\n                        <h4><i class=\"fas fa-history\"></i> Recent Graphs</h4>\n                        <div id=\"loadRecentGraphs\" class=\"load-graphs-list\">\n                            ${this.savedGraphs.length === 0 ? '<p class=\"no-graphs\">No saved graphs found</p>' : ''}\n                        </div>\n                    </div>\n                    <div class=\"load-section\">\n                        <h4><i class=\"fas fa-upload\"></i> Import from File</h4>\n                        <input type=\"file\" id=\"loadFileInputModal\" accept=\".json\" style=\"display: none;\">\n                        <button class=\"btn btn-secondary\" id=\"browseFileBtn\">\n                            <i class=\"fas fa-folder\"></i> Browse Files\n                        </button>\n                    </div>\n                </div>\n                <div class=\"modal-buttons\">\n                    <button class=\"btn btn-secondary\" id=\"cancelLoadDialogBtn\">\n                        <i class=\"fas fa-times\"></i> Cancel\n                    </button>\n                </div>\n            </div>\n        `;\n        \n        document.body.appendChild(dialog);\n        \n        // Populate recent graphs\n        this.populateLoadRecentGraphs();\n        \n        // Add event listeners\n        document.getElementById('browseFileBtn').addEventListener('click', () => {\n            document.getElementById('loadFileInputModal').click();\n        });\n        \n        document.getElementById('loadFileInputModal').addEventListener('change', (e) => {\n            this.handleFileLoad(e);\n            document.body.removeChild(dialog);\n        });\n        \n        document.getElementById('cancelLoadDialogBtn').addEventListener('click', () => {\n            document.body.removeChild(dialog);\n        });\n    }\n    \n    populateLoadRecentGraphs() {\n        const container = document.getElementById('loadRecentGraphs');\n        if (!container) return;\n        \n        container.innerHTML = '';\n        \n        this.savedGraphs.forEach((savedGraph, index) => {\n            const item = document.createElement('div');\n            item.className = 'load-graph-item';\n            item.innerHTML = `\n                <div class=\"load-graph-info\">\n                    <div class=\"load-graph-name\">${savedGraph.name}</div>\n                    <div class=\"load-graph-details\">${savedGraph.vertices} vertices, ${savedGraph.edges} edges</div>\n                    <div class=\"load-graph-time\">${new Date(savedGraph.timestamp).toLocaleString()}</div>\n                </div>\n                <button class=\"btn btn-primary load-graph-btn\" data-index=\"${index}\">\n                    <i class=\"fas fa-download\"></i> Load\n                </button>\n            `;\n            \n            const loadBtn = item.querySelector('.load-graph-btn');\n            loadBtn.addEventListener('click', () => {\n                this.loadSavedGraphWithConfirmation(savedGraph);\n                document.body.removeChild(document.querySelector('.modal-overlay'));\n            });\n            \n            container.appendChild(item);\n        });\n    }\n    \n    toggleDistanceMode() {\n        this.isDistanceMode = !this.isDistanceMode;\n        this.distanceModeVertices = [];\n        this.selectedVertices = [];\n        \n        if (this.isDistanceMode) {\n            document.getElementById('calculateDistance').classList.add('active');\n            this.updateStatus('Distance mode: Click two vertices to calculate shortest path distance');\n        } else {\n            document.getElementById('calculateDistance').classList.remove('active');\n            this.updateStatus('Distance mode disabled');\n        }\n        \n        this.draw();\n    }\n    \n    showDistanceInfo(distance, path) {\n        const distanceInfo = document.getElementById('distanceInfo');\n        const pathInfo = document.getElementById('pathInfo');\n\n        if (distance === -1) {\n            distanceInfo.textContent = 'No path exists between these vertices';\n            pathInfo.textContent = '';\n        } else if (distance === 0) {\n            distanceInfo.textContent = 'Same vertex selected';\n            pathInfo.textContent = '';\n        } else {\n            distanceInfo.textContent = `Shortest path distance: ${distance} edge${distance !== 1 ? 's' : ''}`;\n            pathInfo.textContent = `Path: ${path.map(v => v.label).join(' -> ')}`;\n        }\n        distanceInfo.classList.add('show');\n        pathInfo.classList.add('show');\n        \n        // Hide after 5 seconds\n        setTimeout(() => {\n            distanceInfo.classList.remove('show');\n            pathInfo.classList.remove('show');\n        }, 5000);\n    }\n    \n    clearGraph() {\n        this.vertices = [];\n        this.edges = [];\n        this.nextVertexId = 1;\n        this.selectedVertices = [];\n        this.draggedVertex = null;\n        this.isDragging = false;\n        this.distanceModeVertices = [];\n        this.isDistanceMode = false;\n        this.visitedVertices.clear();\n        this.pathVertices.clear();\n        this.isSearching = false;\n        this.editingVertex = null;\n        \n        // Reset styling properties to defaults\n        this.vertexColor = '#1e293b';\n        this.vertexBorderColor = '#475569';\n        this.vertexFontSize = 14;\n        this.vertexFontFamily = 'Inter';\n        this.vertexFontColor = '#ffffff';\n        \n        this.edgeColor = '#6366f1';\n        this.edgeWidth = 3;\n        this.edgeFontSize = 14;\n        this.edgeFontFamily = 'Inter';\n        this.edgeFontColor = '#06b6d4';\n        \n        document.getElementById('distanceInfo').classList.remove('show');\n        document.getElementById('searchInfo').classList.remove('show');\n        document.getElementById('calculateDistance').classList.remove('active');\n        document.getElementById('runBFS').disabled = false;\n        document.getElementById('runDFS').disabled = false;\n        document.getElementById('stopSearch').disabled = true;\n        \n        // Hide edit label interface\n        document.getElementById('editLabelGroup').style.display = 'none';\n        \n        // Reset saved state since we're clearing the graph\n        this.lastSavedState = null;\n        \n        this.updateInfo();\n        this.draw();\n        this.updateStatus('Graph cleared!');\n        this.updateRootDropdown();\n    }\n    \n    hideInstructions() {\n        const overlay = document.getElementById('instructionsOverlay');\n        overlay.style.display = 'none';\n        this.updateStatus('Instructions hidden. You can start creating your graph!');\n    }\n    \n    updateInfo() {\n        document.getElementById('vertexCount').textContent = this.vertices.length;\n        document.getElementById('edgeCount').textContent = this.edges.length;\n    }\n    \n    updateStatus(message) {\n        document.getElementById('statusMessage').textContent = message;\n    }\n    \n    updateTime() {\n        const now = new Date();\n        const timeString = now.toLocaleTimeString();\n        document.getElementById('currentTime').textContent = timeString;\n    }\n    \n    draw() {\n        // Clear canvas\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        // Draw edges\n        this.edges.forEach(edge => this.drawEdge(edge));\n        \n        // Draw vertices\n        this.vertices.forEach(vertex => this.drawVertex(vertex));\n    }\n    \n    drawEdge(edge) {\n        // Apply shaking animation if this edge is in edit mode\n        let drawFromX = edge.from.x;\n        let drawFromY = edge.from.y;\n        let drawToX = edge.to.x;\n        let drawToY = edge.to.y;\n        \n        if (this.editModeElement === edge && this.editModeType === 'edge') {\n            drawFromX += this.shakeOffset;\n            drawFromY += this.shakeOffset * 0.5;\n            drawToX += this.shakeOffset;\n            drawToY += this.shakeOffset * 0.5;\n        }\n        \n        // Determine edge styling based on individual properties\n        let edgeColor = edge.color || this.edgeColor;\n        let edgeWidth = edge.width || this.edgeWidth;\n        let edgeFontSize = edge.fontSize || this.edgeFontSize;\n        let edgeFontFamily = edge.fontFamily || this.edgeFontFamily;\n        let edgeFontColor = edge.fontColor || this.edgeFontColor;\n        \n        if (this.editModeElement === edge && this.editModeType === 'edge') {\n            edgeColor = '#ef4444';\n        }\n        \n        this.ctx.strokeStyle = edgeColor;\n        this.ctx.lineWidth = edgeWidth;\n        this.ctx.lineCap = 'round';\n        this.ctx.beginPath();\n        \n        if (edge.type === 'curved') {\n            // Draw curved edge with quadratic Bzier curve using fixed control point\n            const controlPoint = {\n                x: (edge.from.x + edge.to.x) / 2,\n                y: (edge.from.y + edge.to.y) / 2 - 40\n            };\n            this.ctx.moveTo(edge.from.x, edge.from.y);\n            this.ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, edge.to.x, edge.to.y);\n        } else {\n            // Draw straight edge\n            this.ctx.moveTo(edge.from.x, edge.from.y);\n            this.ctx.lineTo(edge.to.x, edge.to.y);\n        }\n        this.ctx.stroke();\n        \n        // Draw arrow for directed edges\n        if (edge.direction !== 'undirected') {\n            this.drawArrow(edge);\n        }\n        \n        // Draw weight if exists\n        if (edge.weight !== null && edge.weight !== '') {\n            let midX, midY;\n            if (edge.type === 'curved') {\n                // For curved edges, position weight near the fixed control point\n                midX = (edge.from.x + edge.to.x) / 2;\n                midY = (edge.from.y + edge.to.y) / 2 - 60;\n            } else {\n                // For straight edges, position weight at midpoint\n                midX = (edge.from.x + edge.to.x) / 2;\n                midY = (edge.from.y + edge.to.y) / 2;\n            }\n            \n            // Background for weight text\n            this.ctx.fillStyle = this.currentTheme === 'dark' ? 'rgba(15, 23, 42, 0.9)' : 'rgba(255, 255, 255, 0.9)';\n            this.ctx.fillRect(midX - 20, midY - 12, 40, 24);\n            \n            // Weight text\n            this.ctx.fillStyle = edgeFontColor;\n            this.ctx.font = `bold ${edgeFontSize}px ${edgeFontFamily}`;\n            this.ctx.textAlign = 'center';\n            this.ctx.textBaseline = 'middle';\n            this.ctx.fillText(edge.weight.toString(), midX, midY);\n        }\n        \n        // Add glow effect for edit mode\n        if (this.editModeElement === edge && this.editModeType === 'edge') {\n            this.ctx.shadowColor = '#ef4444';\n            this.ctx.shadowBlur = 15;\n            this.ctx.stroke();\n            this.ctx.shadowBlur = 0;\n        }\n    }\n    \n    drawVertex(vertex) {\n        // Apply shaking animation if this vertex is in edit mode\n        let drawX = vertex.x;\n        let drawY = vertex.y;\n        if (this.editModeElement === vertex && this.editModeType === 'vertex') {\n            drawX += this.shakeOffset;\n        }\n        // Determine vertex color based on state and individual styling\n        let fillColor = vertex.color || this.vertexColor;\n        let borderColor = vertex.borderColor || this.vertexBorderColor;\n        let fontColor = vertex.fontColor || this.vertexFontColor;\n        let fontSize = vertex.fontSize || this.vertexFontSize;\n        let fontFamily = vertex.fontFamily || this.vertexFontFamily;\n        if (this.pathVertices.has(vertex)) {\n            fillColor = '#10b981';\n            borderColor = '#059669';\n            fontColor = '#ffffff';\n        } else if (this.visitedVertices.has(vertex)) {\n            fillColor = '#f59e0b';\n            borderColor = '#d97706';\n            fontColor = '#ffffff';\n        } else if (this.editingVertex === vertex) {\n            fillColor = '#06b6d4';\n            borderColor = '#0891b2';\n            fontColor = '#ffffff';\n        } else if (this.selectedVertices.includes(vertex)) {\n            fillColor = '#6366f1';\n            borderColor = '#4f46e5';\n            fontColor = '#ffffff';\n        } else if (this.distanceModeVertices.includes(vertex)) {\n            fillColor = '#f59e0b';\n            borderColor = '#d97706';\n            fontColor = '#ffffff';\n        } else if (vertex === this.draggedVertex) {\n            fillColor = '#10b981';\n            borderColor = '#059669';\n            fontColor = '#ffffff';\n        }\n        // Remove special red highlight for edit mode (no longer force red)\n        // Adjust colors for light theme\n        if (this.currentTheme === 'light') {\n            if (fillColor === this.vertexColor) {\n                fillColor = '#e2e8f0';\n                borderColor = '#cbd5e1';\n                fontColor = '#1e293b';\n            }\n        }\n        // Draw vertex circle with gradient\n        const gradient = this.ctx.createRadialGradient(\n            drawX - this.vertexSize * 0.3, \n            drawY - this.vertexSize * 0.3, \n            0,\n            drawX, \n            drawY, \n            this.vertexSize\n        );\n        gradient.addColorStop(0, fillColor);\n        gradient.addColorStop(1, this.adjustColor(fillColor, -20));\n        this.ctx.fillStyle = gradient;\n        this.ctx.beginPath();\n        this.ctx.arc(drawX, drawY, this.vertexSize, 0, 2 * Math.PI);\n        this.ctx.fill();\n        // Draw border\n        this.ctx.strokeStyle = borderColor;\n        this.ctx.lineWidth = 3;\n        this.ctx.stroke();\n        // Draw label\n        this.ctx.fillStyle = fontColor;\n        this.ctx.font = `bold ${Math.max(fontSize, this.vertexSize / 2)}px ${fontFamily}`;\n        this.ctx.textAlign = 'center';\n        this.ctx.textBaseline = 'middle';\n        this.ctx.fillText(vertex.label.toString(), drawX, drawY);\n        // Add glow effect for selected vertices\n        if (this.selectedVertices.includes(vertex)) {\n            this.ctx.shadowColor = '#6366f1';\n            this.ctx.shadowBlur = 15;\n            this.ctx.stroke();\n            this.ctx.shadowBlur = 0;\n        }\n        // Add special glow effect for editing vertex\n        if (this.editingVertex === vertex) {\n            this.ctx.shadowColor = '#06b6d4';\n            this.ctx.shadowBlur = 20;\n            this.ctx.stroke();\n            this.ctx.shadowBlur = 0;\n        }\n        // Add special glow effect for edit mode (no color override)\n        if (this.editModeElement === vertex && this.editModeType === 'vertex') {\n            this.ctx.shadowColor = '#ef4444';\n            this.ctx.shadowBlur = 25;\n            this.ctx.stroke();\n            this.ctx.shadowBlur = 0;\n        }\n    }\n    \n    drawArrow(edge) {\n        const arrowLength = 15;\n        const arrowAngle = Math.PI / 6; // 30 degrees\n        \n        let endX, endY;\n        let angle;\n        \n        if (edge.type === 'curved' && edge.controlPoint) {\n            // For curved edges, calculate the angle at the end point using control point\n            const controlPoint = edge.controlPoint;\n            \n            // Calculate the tangent at the end point\n            const dx = edge.to.x - controlPoint.x;\n            const dy = edge.to.y - controlPoint.y;\n            angle = Math.atan2(dy, dx);\n        } else {\n            // For straight edges\n            const dx = edge.to.x - edge.from.x;\n            const dy = edge.to.y - edge.from.y;\n            angle = Math.atan2(dy, dx);\n        }\n        \n        // Determine arrow direction based on edge direction setting\n        if (edge.direction === 'directed-backward') {\n            angle += Math.PI; // Reverse the arrow\n            endX = edge.from.x;\n            endY = edge.from.y;\n        } else {\n            // directed-forward or default\n            endX = edge.to.x;\n            endY = edge.to.y;\n        }\n        \n        // Calculate arrow position (slightly inside the vertex)\n        const vertexRadius = this.vertexSize;\n        const arrowDistance = vertexRadius + 5;\n        \n        const arrowX = endX - arrowDistance * Math.cos(angle);\n        const arrowY = endY - arrowDistance * Math.sin(angle);\n        \n        // Draw arrow\n        this.ctx.strokeStyle = this.edgeColor;\n        this.ctx.lineWidth = this.edgeWidth;\n        this.ctx.lineCap = 'round';\n        this.ctx.lineJoin = 'round';\n        \n        this.ctx.beginPath();\n        this.ctx.moveTo(arrowX, arrowY);\n        this.ctx.lineTo(\n            arrowX - arrowLength * Math.cos(angle - arrowAngle),\n            arrowY - arrowLength * Math.sin(angle - arrowAngle)\n        );\n        this.ctx.moveTo(arrowX, arrowY);\n        this.ctx.lineTo(\n            arrowX - arrowLength * Math.cos(angle + arrowAngle),\n            arrowY - arrowLength * Math.sin(angle + arrowAngle)\n        );\n        this.ctx.stroke();\n    }\n    \n    adjustColor(color, amount) {\n        const hex = color.replace('#', '');\n        const num = parseInt(hex, 16);\n        const r = Math.max(0, Math.min(255, (num >> 16) + amount));\n        const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amount));\n        const b = Math.max(0, Math.min(255, (num & 0x0000FF) + amount));\n        return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;\n    }\n    \n    // Add this method to update the root node dropdown\n    updateRootDropdown() {\n        const rootDropdown = document.getElementById('searchRoot');\n        if (!rootDropdown) return;\n        const current = rootDropdown.value;\n        // Clear all except the first option\n        while (rootDropdown.options.length > 1) {\n            rootDropdown.remove(1);\n        }\n        this.vertices.forEach(v => {\n            const opt = document.createElement('option');\n            opt.value = v.label;\n            opt.textContent = v.label;\n            rootDropdown.appendChild(opt);\n        });\n        // Try to restore previous selection if possible\n        if (current && Array.from(rootDropdown.options).some(o => o.value === current)) {\n            rootDropdown.value = current;\n        } else {\n            rootDropdown.value = '';\n        }\n    }\n} \n\n//# sourceURL=webpack://graph-creator/./src/graphCreator.js?\n}");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles.css */ \"./src/styles.css\");\n/* harmony import */ var _graphCreator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./graphCreator.js */ \"./src/graphCreator.js\");\n\n\n\n// Initialize the application when the page loads\ndocument.addEventListener('DOMContentLoaded', () => {\n    new _graphCreator_js__WEBPACK_IMPORTED_MODULE_1__.GraphCreator();\n}); \n\n//# sourceURL=webpack://graph-creator/./src/index.js?\n}");

/***/ }),

/***/ "./src/styles.css":
/*!************************!*\
  !*** ./src/styles.css ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./styles.css */ \"./node_modules/css-loader/dist/cjs.js!./src/styles.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://graph-creator/./src/styles.css?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;